--- old/Makefile
+++ new/Makefile
@@ -7,8 +7,8 @@
 endif
 
 CC	?= gcc
-CFLAGS += -Wall -std=c99 -Os -DVERSION="\"$(VERSION)\""
-LDFLAGS += -lxcb -lxcb-xinerama -lxcb-randr
+CFLAGS += -Wall -std=c99 -Os -DVERSION="\"$(VERSION)\"" -I/usr/include/freetype2
+LDFLAGS += -lxcb -lxcb-xinerama -lxcb-randr -lX11 -lX11-xcb -lXft -lfreetype -lz -lfontconfig
 CFDEBUG = -g3 -pedantic -Wall -Wunused-parameter -Wlong-long \
           -Wsign-conversion -Wconversion -Wimplicit-function-declaration
 
--- old/lemonbar.c
+++ new/lemonbar.c
@@ -1,12 +1,14 @@
 // vim:sw=4:ts=4:et:
 #define _POSIX_C_SOURCE 200809L
 #include <stdbool.h>
+#include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <signal.h>
 #include <poll.h>
+#include <fcntl.h>
 #include <getopt.h>
 #include <unistd.h>
 #include <errno.h>
@@ -17,8 +19,11 @@
 #endif
 #include <xcb/randr.h>
 
-// Here be dragons
+#include <X11/Xft/Xft.h>
+#include <X11/Xlib-xcb.h>
 
+// Here bet  dragons
+
 #define max(a,b) ((a) > (b) ? (a) : (b))
 #define min(a,b) ((a) < (b) ? (a) : (b))
 #define indexof(c,s) (strchr((s),(c))-(s))
@@ -29,6 +34,9 @@
     uint16_t char_max;
     uint16_t char_min;
     xcb_charinfo_t *width_lut;
+
+    XftFont *xft_ft;
+    int ascent;
 } font_t;
 
 typedef struct monitor_t {
@@ -83,15 +91,25 @@
 
 #define MAX_FONT_COUNT 5
 
+static Display *dpy;
 static xcb_connection_t *c;
+
 static xcb_screen_t *scr;
+static int scr_nbr = 0;
+
 static xcb_gcontext_t gc[GC_MAX];
 static xcb_visualid_t visual;
+static Visual *visual_ptr;
 static xcb_colormap_t colormap;
+
 static monitor_t *monhead, *montail;
 static font_t *font_list[MAX_FONT_COUNT];
 static int font_count = 0;
 static int font_index = -1;
+static int offsets_y[MAX_FONT_COUNT];
+static int offset_y_count = 0;
+static int offset_y_index = 0;
+
 static uint32_t attrs = 0;
 static bool dock = false;
 static bool topbar = true;
@@ -101,12 +119,27 @@
 static rgba_t dfgc, dbgc, dugc;
 static area_stack_t area_stack;
 
+static XftColor sel_fg;
+static XftDraw *xft_draw;
+
+//char width lookuptable
+#define MAX_WIDTHS (1 << 16)
+static wchar_t xft_char[MAX_WIDTHS];
+static char    xft_width[MAX_WIDTHS];
+
 void
 update_gc (void)
 {
     xcb_change_gc(c, gc[GC_DRAW], XCB_GC_FOREGROUND, (const uint32_t []){ fgc.v });
     xcb_change_gc(c, gc[GC_CLEAR], XCB_GC_FOREGROUND, (const uint32_t []){ bgc.v });
     xcb_change_gc(c, gc[GC_ATTR], XCB_GC_FOREGROUND, (const uint32_t []){ ugc.v });
+    XftColorFree(dpy, visual_ptr, colormap , &sel_fg);
+    char color[] = "#ffffff";
+    uint32_t nfgc = fgc.v & 0x00ffffff;
+    snprintf(color, sizeof(color), "#%06X", nfgc);
+    if (!XftColorAllocName (dpy, visual_ptr, colormap, color, &sel_fg)) {
+        fprintf(stderr, "Couldn't allocate xft font color '%s'\n", color);
+    }
 }
 
 void
@@ -189,6 +222,35 @@
 }
 
 int
+xft_char_width_slot (uint16_t ch)
+{
+    int slot = ch % MAX_WIDTHS;
+    while (xft_char[slot] != 0 && xft_char[slot] != ch)
+    {
+        slot = (slot + 1) % MAX_WIDTHS;
+    }
+    return slot;
+}
+
+int xft_char_width (uint16_t ch, font_t *cur_font)
+{
+    int slot = xft_char_width_slot(ch);
+    if (!xft_char[slot]) {
+        XGlyphInfo gi;
+        FT_UInt glyph = XftCharIndex (dpy, cur_font->xft_ft, (FcChar32) ch);
+        XftFontLoadGlyphs (dpy, cur_font->xft_ft, FcFalse, &glyph, 1);
+        XftGlyphExtents (dpy, cur_font->xft_ft, &glyph, 1, &gi);
+        XftFontUnloadGlyphs (dpy, cur_font->xft_ft, &glyph, 1);
+        xft_char[slot] = ch;
+        xft_width[slot] = gi.xOff;
+        return gi.xOff;
+    } else if (xft_char[slot] == ch)
+        return xft_width[slot];
+    else
+        return 0;
+}
+
+int
 shift (monitor_t *mon, int x, int align, int ch_width)
 {
     switch (align) {
@@ -233,19 +295,30 @@
 int
 draw_char (monitor_t *mon, font_t *cur_font, int x, int align, uint16_t ch)
 {
-    int ch_width = (cur_font->width_lut) ?
-        cur_font->width_lut[ch - cur_font->char_min].character_width:
-        cur_font->width;
+    int ch_width;
 
+    if (cur_font->xft_ft) {
+        ch_width = xft_char_width(ch, cur_font);
+    } else {
+        ch_width = (cur_font->width_lut) ?
+            cur_font->width_lut[ch - cur_font->char_min].character_width:
+            cur_font->width;
+    }
+
     x = shift(mon, x, align, ch_width);
 
-    // xcb accepts string in UCS-2 BE, so swap
-    ch = (ch >> 8) | (ch << 8);
-
-    // The coordinates here are those of the baseline
-    xcb_poly_text_16_simple(c, mon->pixmap, gc[GC_DRAW],
-                            x, bh / 2 + cur_font->height / 2 - cur_font->descent,
+    int y = bh / 2 + cur_font->height / 2- cur_font->descent + offsets_y[offset_y_index];
+    if (cur_font->xft_ft) {
+        XftDrawString16 (xft_draw, &sel_fg, cur_font->xft_ft, x,y, &ch, 1);
+    } else {
+        /* xcb accepts string in UCS-2 BE, so swap */
+        ch = (ch >> 8) | (ch << 8);
+        
+        // The coordinates here are those of the baseline
+        xcb_poly_text_16_simple(c, mon->pixmap, gc[GC_DRAW],
+                            x, y,
                             1, &ch);
+    }
 
     draw_lines(mon, x, ch_width);
 
@@ -336,9 +409,9 @@
     }
 
     switch (modifier) {
-        case '+': attrs |= (1<<pos); break;
-        case '-': attrs &=~(1<<pos); break;
-        case '!': attrs ^= (1<<pos); break;
+        case '+': attrs |= (1u<<pos); break;
+        case '-': attrs &=~(1u<<pos); break;
+        case '!': attrs ^= (1u<<pos); break;
     }
 }
 
@@ -459,6 +532,15 @@
 bool
 font_has_glyph (font_t *font, const uint16_t c)
 {
+    if (font->xft_ft) {
+        if (XftCharExists(dpy, font->xft_ft, (FcChar32) c)) {
+            return true;
+        } else {
+            return false;
+        }
+
+    }
+
     if (c < font->char_min || c > font->char_max)
         return false;
 
@@ -473,14 +555,18 @@
 select_drawable_font (const uint16_t c)
 {
     // If the user has specified a font to use, try that first.
-    if (font_index != -1 && font_has_glyph(font_list[font_index - 1], c))
+    if (font_index != -1 && font_has_glyph(font_list[font_index - 1], c)) {
+        offset_y_index = font_index - 1;
         return font_list[font_index - 1];
+    }
 
     // If the end is reached without finding an appropriate font, return NULL.
     // If the font can draw the character, return it.
     for (int i = 0; i < font_count; i++) {
-        if (font_has_glyph(font_list[i], c))
+        if (font_has_glyph(font_list[i], c)) {
+            offset_y_index = i;
             return font_list[i];
+        }
     }
     return NULL;
 }
@@ -504,6 +590,11 @@
     for (monitor_t *m = monhead; m != NULL; m = m->next)
         fill_rect(m->pixmap, gc[GC_CLEAR], 0, 0, m->width, bh);
 
+    /* Create xft drawable */
+    if (!(xft_draw = XftDrawCreate (dpy, cur_mon->pixmap, visual_ptr , colormap))) {
+        fprintf(stderr, "Couldn't create xft drawable\n");
+    }
+
     for (;;) {
         if (*p == '\0' || *p == '\n')
             return;
@@ -560,6 +651,10 @@
                               }
                               else
                               { p++; continue; }
+					          XftDrawDestroy (xft_draw);
+					          if (!(xft_draw = XftDrawCreate (dpy, cur_mon->pixmap, visual_ptr , colormap ))) {
+						        fprintf(stderr, "Couldn't create xft drawable\n");
+					          }
 
                               p++;
                               pos_x = 0;
@@ -602,10 +697,6 @@
             // Eat the trailing }
             p++;
         } else { // utf-8 -> ucs-2
-            // Escaped % symbol, eat the first one
-            if (p[0] == '%' && p[1] == '%')
-                p++;
-
             uint8_t *utf = (uint8_t *)p;
             uint16_t ucs;
 
@@ -649,14 +740,17 @@
             if (!cur_font)
                 continue;
 
-            xcb_change_gc(c, gc[GC_DRAW] , XCB_GC_FONT, (const uint32_t []){ cur_font->ptr });
-
+            if(cur_font->ptr)
+                xcb_change_gc(c, gc[GC_DRAW] , XCB_GC_FONT, (const uint32_t []) {
+                cur_font->ptr
+            });
             int w = draw_char(cur_mon, cur_font, pos_x, align, ucs);
 
             pos_x += w;
             area_shift(cur_mon->window, align, w);
         }
     }
+    XftDrawDestroy (xft_draw);
 }
 
 void
@@ -674,39 +768,60 @@
 
     font = xcb_generate_id(c);
 
-    cookie = xcb_open_font_checked(c, font, strlen(pattern), pattern);
-    if (xcb_request_check (c, cookie)) {
-        fprintf(stderr, "Could not load font \"%s\"\n", pattern);
-        return;
-    }
-
     font_t *ret = calloc(1, sizeof(font_t));
 
     if (!ret)
         return;
 
-    queryreq = xcb_query_font(c, font);
-    font_info = xcb_query_font_reply(c, queryreq, NULL);
+    cookie = xcb_open_font_checked(c, font, strlen(pattern), pattern);
+    if (!xcb_request_check (c, cookie)) {
+        queryreq = xcb_query_font(c, font);
+        font_info = xcb_query_font_reply(c, queryreq, NULL);
 
-    ret->ptr = font;
-    ret->descent = font_info->font_descent;
-    ret->height = font_info->font_ascent + font_info->font_descent;
-    ret->width = font_info->max_bounds.character_width;
-    ret->char_max = font_info->max_byte1 << 8 | font_info->max_char_or_byte2;
-    ret->char_min = font_info->min_byte1 << 8 | font_info->min_char_or_byte2;
-
-    // Copy over the width lut as it's part of font_info
-    int lut_size = sizeof(xcb_charinfo_t) * xcb_query_font_char_infos_length(font_info);
-    if (lut_size) {
-        ret->width_lut = malloc(lut_size);
-        memcpy(ret->width_lut, xcb_query_font_char_infos(font_info), lut_size);
+        ret->xft_ft = NULL;
+        ret->ptr = font;
+        ret->descent = font_info->font_descent;
+        ret->height = font_info->font_ascent + font_info->font_descent;
+        ret->width = font_info->max_bounds.character_width;
+        ret->char_max = font_info->max_byte1 << 8 | font_info->max_char_or_byte2;
+        ret->char_min = font_info->min_byte1 << 8 | font_info->min_char_or_byte2;
+        // Copy over the width lut as it's part of font_info
+        int lut_size = sizeof(xcb_charinfo_t) * xcb_query_font_char_infos_length(font_info);
+        if (lut_size) {
+            ret->width_lut = malloc(lut_size);
+            memcpy(ret->width_lut, xcb_query_font_char_infos(font_info), lut_size);
+        }
+        free(font_info);
+    } else if ((ret->xft_ft = XftFontOpenName (dpy, scr_nbr, pattern))) {
+        ret->ptr = 0;
+        ret->ascent = ret->xft_ft->ascent;
+        ret->descent = ret->xft_ft->descent;
+        ret->height = ret->ascent + ret->descent;
+    } else {
+        fprintf(stderr, "Could not load font %s\n", pattern);
+        free(ret);
+        return;
     }
 
-    free(font_info);
-
     font_list[font_count++] = ret;
 }
 
+void add_y_offset(int offset) {
+    if (offset_y_count >= MAX_FONT_COUNT) {
+        fprintf(stderr, "Max offset count reached. Could not set offset \"%d\"\n", offset);
+        return;
+    }
+
+    offsets_y[offset_y_count] = strtol(optarg, NULL, 10);
+    if (offset_y_count == 0) {
+        for (int i = 1; i < MAX_FONT_COUNT; ++i) {
+            offsets_y[i] = offsets_y[0];
+        }
+    }
+    ++offset_y_count;
+}
+
+
 enum {
     NET_WM_WINDOW_TYPE,
     NET_WM_WINDOW_TYPE_DOCK,
@@ -756,19 +871,22 @@
         if (topbar) {
             strut[2] = bh;
             strut[8] = mon->x;
-            strut[9] = mon->x + mon->width - 1;
+            strut[9] = mon->x + mon->width;
         } else {
             strut[3]  = bh;
             strut[10] = mon->x;
-            strut[11] = mon->x + mon->width - 1;
+            strut[11] = mon->x + mon->width;
         }
 
         xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_WINDOW_TYPE], XCB_ATOM_ATOM, 32, 1, &atom_list[NET_WM_WINDOW_TYPE_DOCK]);
         xcb_change_property(c, XCB_PROP_MODE_APPEND,  mon->window, atom_list[NET_WM_STATE], XCB_ATOM_ATOM, 32, 2, &atom_list[NET_WM_STATE_STICKY]);
-        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_DESKTOP], XCB_ATOM_CARDINAL, 32, 1, (const uint32_t []){ -1 } );
+        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_DESKTOP], XCB_ATOM_CARDINAL, 32, 1, (const uint32_t []) {
+            0u - 1u
+        } );
         xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_STRUT_PARTIAL], XCB_ATOM_CARDINAL, 32, 12, strut);
         xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_STRUT], XCB_ATOM_CARDINAL, 32, 4, strut);
         xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8, 3, "bar");
+        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_CLASS, XCB_ATOM_STRING, 8, 12, "lemonbar\0Bar");
     }
 }
 
@@ -1028,22 +1146,21 @@
 xcb_visualid_t
 get_visual (void)
 {
-    xcb_depth_iterator_t iter;
 
-    iter = xcb_screen_allowed_depths_iterator(scr);
+    XVisualInfo xv; 
+    xv.depth = 32;
+    int result = 0;
+    XVisualInfo* result_ptr = NULL; 
+    result_ptr = XGetVisualInfo(dpy, VisualDepthMask, &xv, &result);
 
-    // Try to find a RGBA visual
-    while (iter.rem) {
-        xcb_visualtype_t *vis = xcb_depth_visuals(iter.data);
-
-        if (iter.data->depth == 32)
-            return vis->visual_id;
-
-        xcb_depth_next(&iter);
+    if (result > 0) {
+        visual_ptr = result_ptr->visual;
+        return result_ptr->visualid;
     }
-
+    
     // Fallback to the default one
-    return scr->root_visual;
+    visual_ptr = DefaultVisual(dpy, scr_nbr);	
+	return scr->root_visual;
 }
 
 // Parse an X-styled geometry string, we don't support signed offsets though.
@@ -1100,8 +1217,17 @@
 void
 xconn (void)
 {
-    // Connect to X
-    c = xcb_connect (NULL, NULL);
+    if ((dpy = XOpenDisplay(0)) == NULL) {
+        fprintf (stderr, "Couldnt open display\n");
+    }
+
+    if ((c = XGetXCBConnection(dpy)) == NULL) {
+        fprintf (stderr, "Couldnt connect to X\n");
+        exit (EXIT_FAILURE);
+    }
+
+	XSetEventQueueOwner(dpy, XCBOwnsEventQueue);
+
     if (xcb_connection_has_error(c)) {
         fprintf(stderr, "Couldn't connect to X\n");
         exit(EXIT_FAILURE);
@@ -1118,7 +1244,7 @@
 }
 
 void
-init (char *wm_name)
+init (char *wm_name, char *wm_instance)
 {
     // Try to load a default font
     if (!font_count)
@@ -1213,8 +1339,33 @@
         // Set the WM_NAME atom to the user specified value
         if (wm_name)
             xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8 ,strlen(wm_name), wm_name);
+
+        // set the WM_CLASS atom instance to the executable name
+        if (wm_instance) {
+            char *wm_class;
+            int wm_class_offset, wm_class_len;
+
+            // WM_CLASS is nullbyte seperated: wm_instance + "\0Bar\0"
+            wm_class_offset = strlen(wm_instance) + 1;
+            wm_class_len = wm_class_offset + 4;
+
+            wm_class = calloc(1, wm_class_len + 1);
+            strcpy(wm_class, wm_instance);
+            strcpy(wm_class+wm_class_offset, "Bar");
+
+            xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_CLASS, XCB_ATOM_STRING, 8, wm_class_len, wm_class);
+
+            free(wm_class);
+        }
     }
 
+    char color[] = "#ffffff";
+    uint32_t nfgc = fgc.v & 0x00ffffff;
+    snprintf(color, sizeof(color), "#%06X", nfgc);
+
+    if (!XftColorAllocName (dpy, visual_ptr, colormap, color, &sel_fg)) {
+        fprintf(stderr, "Couldn't allocate xft font color '%s'\n", color);
+    }
     xcb_flush(c);
 }
 
@@ -1222,10 +1373,14 @@
 cleanup (void)
 {
     free(area_stack.area);
-
-    for (int i = 0; i < font_count; i++) {
-        xcb_close_font(c, font_list[i]->ptr);
-        free(font_list[i]->width_lut);
+    for (int i = 0; font_list[i]; i++) {
+        if (font_list[i]->xft_ft) {
+            XftFontClose (dpy, font_list[i]->xft_ft);
+        }
+        else {
+            xcb_close_font(c, font_list[i]->ptr);
+            free(font_list[i]->width_lut);
+        }
         free(font_list[i]);
     }
 
@@ -1237,7 +1392,7 @@
         monhead = next;
     }
 
-    xcb_free_colormap(c, colormap);
+    XftColorFree(dpy, visual_ptr, colormap, &sel_fg);
 
     if (gc[GC_DRAW])
         xcb_free_gc(c, gc[GC_DRAW]);
@@ -1249,6 +1404,21 @@
         xcb_disconnect(c);
 }
 
+char*
+strip_path(char *path)
+{
+    char *slash;
+
+    if (path == NULL || *path == '\0')
+        return strdup("lemonbar");
+
+    slash = strrchr(path, '/');
+    if (slash != NULL)
+        return strndup(slash + 1, 31);
+
+    return strndup(path, 31);
+}
+
 void
 sighandle (int signal)
 {
@@ -1271,6 +1441,7 @@
     int geom_v[4] = { -1, -1, 0, 0 };
     int ch, areas;
     char *wm_name;
+    char *instance_name;
 
     // Install the parachute!
     atexit(cleanup);
@@ -1286,13 +1457,15 @@
     areas = 10;
     wm_name = NULL;
 
+    instance_name = strip_path(argv[0]);
+
     // Connect to the Xserver and initialize scr
     xconn();
 
-    while ((ch = getopt(argc, argv, "hg:bdf:a:pu:B:F:U:n:")) != -1) {
+    while ((ch = getopt(argc, argv, "hg:bdf:a:pu:B:F:U:n:o:")) != -1) {
         switch (ch) {
             case 'h':
-                printf ("lemonbar version %s\n", VERSION);
+                printf ("lemonbar version %s patched with XFT support\n", VERSION);
                 printf ("usage: %s [-h | -g | -b | -d | -f | -a | -p | -n | -u | -B | -F]\n"
                         "\t-h Show this help\n"
                         "\t-g Set the bar geometry {width}x{height}+{xoffset}+{yoffset}\n"
@@ -1304,7 +1477,8 @@
                         "\t-n Set the WM_NAME atom to the specified value for this bar\n"
                         "\t-u Set the underline/overline height in pixels\n"
                         "\t-B Set background color in #AARRGGBB\n"
-                        "\t-F Set foreground color in #AARRGGBB\n", argv[0]);
+                        "\t-F Set foreground color in #AARRGGBB\n"
+                        "\t-o Add a vertical offset to the text, it can be negative\n", argv[0]);
                 exit (EXIT_SUCCESS);
             case 'g': (void)parse_geometry_string(optarg, geom_v); break;
             case 'p': permanent = true; break;
@@ -1313,6 +1487,7 @@
             case 'd': dock = true; break;
             case 'f': font_load(optarg); break;
             case 'u': bu = strtoul(optarg, NULL, 10); break;
+            case 'o': add_y_offset(strtol(optarg, NULL, 10)); break;
             case 'B': dbgc = bgc = parse_color(optarg, NULL, (rgba_t)0x00000000U); break;
             case 'F': dfgc = fgc = parse_color(optarg, NULL, (rgba_t)0xffffffffU); break;
             case 'U': dugc = ugc = parse_color(optarg, NULL, fgc); break;
@@ -1342,12 +1517,17 @@
     by = geom_v[3];
 
     // Do the heavy lifting
-    init(wm_name);
+    init(wm_name, instance_name);
     // The string is strdup'd when the command line arguments are parsed
     free(wm_name);
+    // The string is strdup'd when stripping argv[0]
+    free(instance_name);
     // Get the fd to Xserver
     pollin[1].fd = xcb_get_file_descriptor(c);
 
+    // Prevent fgets to block
+    fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
+	
     for (;;) {
         bool redraw = false;
 
@@ -1361,9 +1541,9 @@
                 else break;                         // ...bail out
             }
             if (pollin[0].revents & POLLIN) { // New input, process it
-                if (fgets(input, sizeof(input), stdin) == NULL)
-                    break; // EOF received
-
+                input[0] = '\0';
+                while (fgets(input, sizeof(input), stdin) != NULL)
+                    ; // Drain the buffer, the last line is actually used
                 parse(input);
                 redraw = true;
             }
