--- old/man/picom.1.asciidoc
+++ new/man/picom.1.asciidoc
@@ -106,6 +106,12 @@
 *--inactive-dim* 'VALUE'::
 	Dim inactive windows. (0.0 - 1.0, defaults to 0.0)
 
+*--corner-radius* 'VALUE'::
+	Round the corners of windows. (defaults to 0).
+
+*--rounded-corners-exclude* 'CONDITION'::
+	Exclude conditions for rounded corners.
+
 *--mark-wmwin-focused*::
 	Try to detect WM windows (a non-override-redirect window with no child that has 'WM_STATE') and mark them as active.
 
--- old/src/backend/backend.c
+++ new/src/backend/backend.c
@@ -151,7 +151,7 @@
 	}
 
 	if (ps->root_image) {
-		ps->backend_data->ops->compose(ps->backend_data, ps->root_image, 0, 0,
+		ps->backend_data->ops->compose(ps->backend_data, t, ps->root_image, 0, 0,
 		                               &reg_paint, &reg_visible);
 	} else {
 		ps->backend_data->ops->fill(ps->backend_data, (struct color){0, 0, 0, 1},
@@ -171,7 +171,7 @@
 
 		// The bounding shape of the window, in global/target coordinates
 		// reminder: bounding shape contains the WM frame
-		auto reg_bound = win_get_bounding_shape_global_by_val(w);
+		auto reg_bound = win_get_bounding_shape_global_by_val(w, true);
 
 		// The clip region for the current window, in global/target coordinates
 		// reg_paint_in_bound \in reg_paint
@@ -230,7 +230,7 @@
 				assert(ps->o.blur_background_frame);
 				assert(real_win_mode == WMODE_FRAME_TRANS);
 
-				auto reg_blur = win_get_region_frame_local_by_val(w);
+				auto reg_blur = win_get_region_frame_local_by_val(w, true);
 				pixman_region32_translate(&reg_blur, w->g.x, w->g.y);
 				// make sure reg_blur \in reg_paint
 				pixman_region32_intersect(&reg_blur, &reg_blur, &reg_paint);
@@ -286,7 +286,7 @@
 			assert(w->shadow_image);
 			if (w->opacity == 1) {
 				ps->backend_data->ops->compose(
-				    ps->backend_data, w->shadow_image, w->g.x + w->shadow_dx,
+				    ps->backend_data, w, w->shadow_image, w->g.x + w->shadow_dx,
 				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
 			} else {
 				auto new_img = ps->backend_data->ops->copy(
@@ -295,7 +295,7 @@
 				    ps->backend_data, IMAGE_OP_APPLY_ALPHA_ALL, new_img,
 				    NULL, &reg_visible, (double[]){w->opacity});
 				ps->backend_data->ops->compose(
-				    ps->backend_data, new_img, w->g.x + w->shadow_dx,
+				    ps->backend_data, w, new_img, w->g.x + w->shadow_dx,
 				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
 				ps->backend_data->ops->release_image(ps->backend_data, new_img);
 			}
@@ -311,7 +311,7 @@
 
 		// Draw window on target
 		if (!w->invert_color && !w->dim && w->frame_opacity == 1 && w->opacity == 1) {
-			ps->backend_data->ops->compose(ps->backend_data, w->win_image,
+			ps->backend_data->ops->compose(ps->backend_data, w, w->win_image,
 			                               w->g.x, w->g.y,
 			                               &reg_paint_in_bound, &reg_visible);
 		} else if (w->opacity * MAX_ALPHA >= 1) {
@@ -360,7 +360,7 @@
 				    &reg_visible_local, (double[]){dim_opacity});
 			}
 			if (w->frame_opacity != 1) {
-				auto reg_frame = win_get_region_frame_local_by_val(w);
+				auto reg_frame = win_get_region_frame_local_by_val(w, true);
 				ps->backend_data->ops->image_op(
 				    ps->backend_data, IMAGE_OP_APPLY_ALPHA, new_img, &reg_frame,
 				    &reg_visible_local, (double[]){w->frame_opacity});
@@ -371,7 +371,7 @@
 				    ps->backend_data, IMAGE_OP_APPLY_ALPHA_ALL, new_img,
 				    NULL, &reg_visible_local, (double[]){w->opacity});
 			}
-			ps->backend_data->ops->compose(ps->backend_data, new_img, w->g.x,
+			ps->backend_data->ops->compose(ps->backend_data, w, new_img, w->g.x,
 			                               w->g.y, &reg_paint_in_bound,
 			                               &reg_visible);
 			ps->backend_data->ops->release_image(ps->backend_data, new_img);
--- old/src/backend/backend.h
+++ new/src/backend/backend.h
@@ -28,6 +28,9 @@
 	/// Whether the backend can accept new render request at the moment
 	bool busy;
 	// ...
+
+	// Session data
+	session_t *ps;
 } backend_t;
 
 typedef void (*backend_ready_callback_t)(void *);
@@ -126,7 +129,7 @@
 	 * @param reg_paint    the clip region, in target coordinates
 	 * @param reg_visible the visible region, in target coordinates
 	 */
-	void (*compose)(backend_t *backend_data, void *image_data, int dst_x, int dst_y,
+	void (*compose)(backend_t *backend_data, struct managed_win *const w, void *image_data, int dst_x, int dst_y,
 	                const region_t *reg_paint, const region_t *reg_visible);
 
 	/// Fill rectangle of the rendering buffer, mostly for debug purposes, optional.
--- old/src/backend/backend_common.c
+++ new/src/backend/backend_common.c
@@ -368,4 +368,5 @@
 	base->root = ps->root;
 	base->busy = false;
 	base->ops = NULL;
+	base->ps = ps;
 }
--- old/src/backend/dummy/dummy.c
+++ new/src/backend/dummy/dummy.c
@@ -56,7 +56,7 @@
 	assert(*tmp->refcount > 0);
 }
 
-void dummy_compose(struct backend_base *base, void *image, int dst_x attr_unused,
+void dummy_compose(struct backend_base *base, struct managed_win *w attr_unused, void *image, int dst_x attr_unused,
                    int dst_y attr_unused, const region_t *reg_paint attr_unused,
                    const region_t *reg_visible attr_unused) {
 	dummy_check_image(base, image);
--- old/src/backend/gl/gl_common.c
+++ new/src/backend/gl/gl_common.c
@@ -504,7 +504,7 @@
 }
 
 // TODO: make use of reg_visible
-void gl_compose(backend_t *base, void *image_data, int dst_x, int dst_y,
+void gl_compose(backend_t *base, struct managed_win *w attr_unused, void *image_data, int dst_x, int dst_y,
                 const region_t *reg_tgt, const region_t *reg_visible attr_unused) {
 	auto gd = (struct gl_data *)base;
 	struct gl_image *img = image_data;
--- old/src/backend/gl/gl_common.h
+++ new/src/backend/gl/gl_common.h
@@ -98,7 +98,7 @@
 /**
  * @brief Render a region with texture data.
  */
-void gl_compose(backend_t *, void *ptex, int dst_x, int dst_y, const region_t *reg_tgt,
+void gl_compose(backend_t *, struct managed_win *, void *ptex, int dst_x, int dst_y, const region_t *reg_tgt,
                 const region_t *reg_visible);
 
 void gl_resize(struct gl_data *, int width, int height);
--- old/src/backend/xrender/xrender.c
+++ new/src/backend/xrender/xrender.c
@@ -90,7 +90,9 @@
 	bool owned;
 };
 
-static void compose(backend_t *base, void *img_data, int dst_x, int dst_y,
+uint32_t make_rounded_window_shape(xcb_render_trapezoid_t traps[], uint32_t max_ntraps, int cr, int wid, int hei);
+
+static void compose(backend_t *base, struct managed_win *w, void *img_data, int dst_x, int dst_y,
                     const region_t *reg_paint, const region_t *reg_visible) {
 	struct _xrender_data *xd = (void *)base;
 	struct _xrender_image_data *img = img_data;
@@ -104,10 +106,52 @@
 	// sure we get everything into the buffer
 	x_clear_picture_clip_region(base->c, img->pict);
 
-	x_set_picture_clip_region(base->c, xd->back[2], 0, 0, &reg);
-	xcb_render_composite(base->c, op, img->pict, alpha_pict, xd->back[2], 0, 0, 0, 0,
-	                     to_i16_checked(dst_x), to_i16_checked(dst_y),
-	                     to_u16_checked(img->ewidth), to_u16_checked(img->eheight));
+	// Are we rounding corners?
+	session_t *ps = base->ps;
+	int cr = (w ? w->corner_radius : 0);
+
+	if (cr == 0) {
+		x_set_picture_clip_region(base->c, xd->back[2], 0, 0, &reg);
+		xcb_render_composite(base->c, op, img->pict, alpha_pict, xd->back[2], 0, 0, 0, 0,
+	                    	 to_i16_checked(dst_x), to_i16_checked(dst_y),
+	                    	 to_u16_checked(img->ewidth), to_u16_checked(img->eheight));
+	} else {
+		// Rounded corners
+		const int fullwid = w ? w->widthb : 0;
+		const int fullhei = w ? w-> heightb : 0;
+		//const int fullwid = img->width;
+		//const int fullhei = img->height;
+		//log_warn("f(%d, %d) imge(%d %d) imgf(%d %d) sdw(%d %d) dst(%d %d) s:%d b:%d", fullwid, fullhei, img->ewidth, img->eheight, img->width, img->height, w->shadow_width, w->shadow_height, dst_x, dst_y, w->shadow, w->g.border_width);
+		xcb_render_picture_t p_tmp = x_create_picture_with_standard(
+			ps->c, ps->root, fullwid, fullhei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+		xcb_render_color_t trans = {
+			.red = 0, .blue = 0, .green = 0, .alpha = 0};
+		const xcb_rectangle_t rect = {.x = 0,
+										.y = 0,
+										.width = to_u16_checked(fullwid),
+										.height = to_u16_checked(fullhei)};
+		xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC,
+									p_tmp, trans, 1, &rect);
+
+		uint32_t max_ntraps = to_u32_checked(cr);
+		xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+
+		uint32_t n = make_rounded_window_shape(traps, max_ntraps, cr, fullwid, fullhei);
+
+		xcb_render_trapezoids(
+			ps->c, XCB_RENDER_PICT_OP_OVER, alpha_pict, p_tmp,
+			x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8),
+			0, 0, n, traps);
+
+		x_set_picture_clip_region(base->c, xd->back[2], 0, 0, &reg);
+		xcb_render_composite(base->c, XCB_RENDER_PICT_OP_OVER, img->pict, p_tmp, xd->back[2],
+							0, 0, 0, 0,
+							//0, 0, to_i16_checked(x), to_i16_checked(y),
+							to_i16_checked(dst_x), to_i16_checked(dst_y),
+							to_u16_checked(img->ewidth), to_u16_checked(img->eheight));
+
+		xcb_render_free_picture(ps->c, p_tmp);
+	}
 	pixman_region32_fini(&reg);
 }
 
@@ -242,6 +286,7 @@
 	xcb_render_free_picture(c, tmp_picture[0]);
 	xcb_render_free_picture(c, tmp_picture[1]);
 	pixman_region32_fini(&reg_op);
+    pixman_region32_fini(&reg_op_resized);
 	return true;
 }
 
--- old/src/config.c
+++ new/src/config.c
@@ -560,6 +560,8 @@
 	    .no_ewmh_fullscreen = false,
 
 	    .track_leader = false,
+
+	    .rounded_corners_blacklist = NULL
 	};
 
 	char *ret = NULL;
--- old/src/config.h
+++ new/src/config.h
@@ -23,8 +23,8 @@
 #include "kernel.h"
 #include "log.h"
 #include "region.h"
-#include "win_defs.h"
 #include "types.h"
+#include "win_defs.h"
 
 typedef struct session session_t;
 
@@ -237,6 +237,10 @@
 	// Make transparent windows clip other windows, instead of blending on top of
 	// them
 	bool transparent_clipping;
+	// === Rounded corners related ===
+	int corner_radius;
+	/// Rounded corners blacklist. A linked list of conditions.
+	c2_lptr_t *rounded_corners_blacklist;
 } options_t;
 
 extern const char *const BACKEND_STRS[NUM_BKEND + 1];
--- old/src/config_libconfig.c
+++ new/src/config_libconfig.c
@@ -367,6 +367,10 @@
 	// --active_opacity
 	if (config_lookup_float(&cfg, "active-opacity", &dval))
 		opt->active_opacity = normalize_d(dval);
+	// --corner-radius
+	config_lookup_int(&cfg, "corner-radius", &opt->corner_radius);
+	// --rounded-corners-exclude
+	parse_cfg_condlst(&cfg, &opt->rounded_corners_blacklist, "rounded-corners-exclude");
 	// -e (frame_opacity)
 	config_lookup_float(&cfg, "frame-opacity", &opt->frame_opacity);
 	// -c (shadow_enable)
--- old/src/event.c
+++ new/src/event.c
@@ -377,6 +377,7 @@
 	region_t region;
 	pixman_region32_init_rects(&region, rects, nrects);
 	add_damage(ps, &region);
+    pixman_region32_fini(&region);
 }
 
 static inline void ev_expose(session_t *ps, xcb_expose_event_t *ev) {
@@ -622,14 +623,14 @@
 	 * if we attempt to rebuild border_size
 	 */
 	// Mark the old border_size as damaged
-	region_t tmp = win_get_bounding_shape_global_by_val(w);
+	region_t tmp = win_get_bounding_shape_global_by_val(w, true);
 	add_damage(ps, &tmp);
 	pixman_region32_fini(&tmp);
 
 	win_update_bounding_shape(ps, w);
 
 	// Mark the new border_size as damaged
-	tmp = win_get_bounding_shape_global_by_val(w);
+	tmp = win_get_bounding_shape_global_by_val(w, true);
 	add_damage(ps, &tmp);
 	pixman_region32_fini(&tmp);
 
--- old/src/opengl.c
+++ new/src/opengl.c
@@ -95,6 +95,19 @@
 			ppass->unifm_offset_x = -1;
 			ppass->unifm_offset_y = -1;
 		}
+
+		ps->psglx->round_passes = ccalloc(2, glx_round_pass_t);
+		for (int i = 0; i < 2; ++i) {
+			glx_round_pass_t *ppass = &ps->psglx->round_passes[i];
+			ppass->unifm_radius = -1;
+			ppass->unifm_texcoord = -1;
+			ppass->unifm_texsize = -1;
+			ppass->unifm_borderw = -1;
+			ppass->unifm_borderc = -1;
+			ppass->unifm_resolution = -1;
+			ppass->unifm_tex_scr = -1;
+			ppass->unifm_tex_wnd = -1;
+		}
 	}
 
 	glx_session_t *psglx = ps->psglx;
@@ -239,6 +252,15 @@
 	}
 	free(ps->psglx->blur_passes);
 
+	for (int i = 0; i < 2; ++i) {
+		glx_round_pass_t *ppass = &ps->psglx->round_passes[i];
+		if (ppass->frag_shader)
+			glDeleteShader(ppass->frag_shader);
+		if (ppass->prog)
+			glDeleteProgram(ppass->prog);
+	}
+	free(ps->psglx->round_passes);
+
 	glx_free_prog_main(&ps->glx_prog_win);
 
 	gl_check_err();
@@ -413,7 +435,226 @@
 	return true;
 }
 
+static inline bool glx_init_frag_shader_corners(glx_round_pass_t *ppass,
+			const int shader_idx, const char *PREFIX_STR, const char* SHADER_STR,
+			const char *extension, const char *sampler_type, const char *texture_func) {
+
+	// Build rounded corners shader
+	{
+		auto len = strlen(PREFIX_STR) + strlen(extension)
+					+ strlen(sampler_type)*2 + strlen(texture_func)*2
+					+ strlen(SHADER_STR) + 1;
+		char *shader_str = calloc(len, sizeof(char));
+		if (!shader_str) {
+			log_error("Failed to allocate %zd bytes for shader string.", len);
+			return false;
+		}
+
+		char *pc = shader_str;
+		sprintf(pc, PREFIX_STR, extension, sampler_type, sampler_type, texture_func, texture_func);
+		pc += strlen(pc);
+		assert(strlen(shader_str) < len);
+
+		sprintf(pc, SHADER_STR);
+		assert(strlen(shader_str) < len);
+#ifdef DEBUG_GLX
+		log_debug("Generated rounded corners shader %d:\n%s\n", shader_idx, shader_str);
+#endif
+
+		//log_info("Generated rounded corners shader %d:\n%s\n", shader_idx, shader_str);
+
+		ppass->frag_shader = gl_create_shader(GL_FRAGMENT_SHADER, shader_str);
+		free(shader_str);
+
+		if (!ppass->frag_shader) {
+			log_error("Failed to create rounded corners fragment shader.");
+			return false;
+		}
+
+		// Build program
+		ppass->prog = gl_create_program(&ppass->frag_shader, 1);
+		if (!ppass->prog) {
+			log_error("Failed to create GLSL program.");
+			return false;
+		}
+
+		// Get uniform addresses
+#define P_GET_UNIFM_LOC(name, target)											\
+{																				\
+	ppass->target = glGetUniformLocation(ppass->prog, name);					\
+	if (ppass->target < 0) {													\
+		log_error("Failed to get location of rounded corners uniform '" name	\
+					"'. Might be troublesome. (shader_idx: %d)"					\
+					, shader_idx);												\
+	} 																			\
+}
+		P_GET_UNIFM_LOC("u_radius", unifm_radius);
+		P_GET_UNIFM_LOC("u_texcoord", unifm_texcoord);
+		P_GET_UNIFM_LOC("u_texsize", unifm_texsize);
+		P_GET_UNIFM_LOC("u_borderw", unifm_borderw);
+		P_GET_UNIFM_LOC("u_borderc", unifm_borderc);
+		P_GET_UNIFM_LOC("u_resolution", unifm_resolution);
+		P_GET_UNIFM_LOC("tex_scr", unifm_tex_scr);
+		// We don't need this one anymore since we get
+		// the border color using glReadPixel
+		// uncomment if you need to use 'tex_wnd' in the shader
+		//P_GET_UNIFM_LOC("tex_wnd", unifm_tex_wnd);
+#undef P_GET_UNIFM_LOC
+	}
+
+	return true;
+}
+
 /**
+ * Initialize GLX rounded corners filter.
+ */
+bool glx_init_rounded_corners(session_t *ps) {
+
+	{
+		char *lc_numeric_old = strdup(setlocale(LC_NUMERIC, NULL));
+		// Enforce LC_NUMERIC locale "C" here to make sure decimal point is sane
+		// Thanks to hiciu for reporting.
+		setlocale(LC_NUMERIC, "C");
+
+		static const char *FRAG_SHADER_PREFIX =
+			"#version 110\n"
+			"%s"  // extensions
+			"uniform float u_radius;\n"
+			"uniform float u_borderw;\n"
+			"uniform vec4 u_borderc;\n"
+			"uniform vec2 u_texcoord;\n"
+			"uniform vec2 u_texsize;\n"
+			"uniform vec2 u_resolution;\n"
+			"uniform %s tex_scr;\n" // sampler2D | sampler2DRect
+			"uniform %s tex_wnd;\n" // sampler2D | sampler2DRect
+			"\n"
+			"// https://www.shadertoy.com/view/ltS3zW\n"
+			"float RectSDF(vec2 p, vec2 b, float r) {\n"
+			"  vec2 d = abs(p) - b + vec2(r);\n"
+			"  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n"
+			"}\n\n"
+			"void main()\n"
+			"{\n"
+			"  vec2 coord = vec2(u_texcoord.x, u_resolution.y-u_texsize.y-u_texcoord.y);\n"
+			"  // Get the window_bg color (so we can \"erase\" corners) from the bg texture\n"
+			"  // and the border color from the mid x-axis of the target window (hacky...)\n"
+			"  vec4 u_v4WndBgColor = %s(tex_scr, vec2(gl_TexCoord[0].st));\n"
+			"  //vec4 u_v4BorderColor = %s(tex_wnd, vec2(0, u_texsize.t/2.));\n"
+			"  vec4 u_v4BorderColor = u_borderc;\n"
+			"  vec4 u_v4FillColor = vec4(0.0, 0.0, 0.0, 0.0);  // Inside rect, transparent\n"
+			"  vec4 v4FromColor = u_v4BorderColor;	//Always the border color. If no border, this still should be set\n"
+			"  vec4 v4ToColor = u_v4WndBgColor;		//Outside corners color, we set it to background texture\n"
+			"\n";
+
+		// Fragment shader (round corners)
+		// dst0 shader
+		static const char *FRAG_SHADER_ROUND_CORNERS_0 =
+			"  float u_fRadiusPx = u_radius;\n"
+			"  float u_fHalfBorderThickness = u_borderw / 2.0;\n"
+			"  //v4FromColor = u_v4BorderColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+			"  //u_v4FillColor = vec4(0.0, 0.0, 0.0, 0.0);  // Inside rect color\n"
+			
+			"\n"
+			"  vec2 u_v2HalfShapeSizePx = u_texsize/2.0 - vec2(u_fHalfBorderThickness);\n"
+			"  vec2 v_v2CenteredPos = (gl_FragCoord.xy - u_texsize.xy / 2.0 - coord);\n"
+			"\n"
+			"  float fDist = RectSDF(v_v2CenteredPos, u_v2HalfShapeSizePx, u_fRadiusPx - u_fHalfBorderThickness);\n"
+			"  if (u_fHalfBorderThickness > 0.0) {\n"
+			"    if (fDist < 0.0) {\n"
+			"      v4ToColor = u_v4FillColor;\n"
+			"    }\n"
+			"    fDist = abs(fDist) - u_fHalfBorderThickness;\n"
+			"  } else {\n"
+			"    v4FromColor = u_v4FillColor;\n"
+			"  }\n"
+			"  float fBlendAmount = clamp(fDist + 0.5, 0.0, 1.0);\n"
+			"  //vec4 c = fDist <= 0.0 ? v4FromColor : v4ToColor;\n"
+			"  vec4 c = mix(v4FromColor, v4ToColor, fBlendAmount);\n"
+			"\n"
+			"  // final color\n"
+			"  if ( c == vec4(0.0,0.0,0.0,0.0) ) discard; else\n"
+			"  gl_FragColor = c;\n"
+			"}\n";
+			
+		// Fragment shader (round corners)
+		// dst1 shader
+		static const char *FRAG_SHADER_ROUND_CORNERS_1 =
+			"  float u_fRadiusPx = u_radius + 25.0;\n"
+			"  float u_fHalfBorderThickness = u_borderw / 2.0;\n"
+			"  //float u_fHalfBorderThickness = 20.0 /2.0;\n"
+			"  //u_v4FillColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
+			"  //v4FromColor = u_v4BorderColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+			"  //v4ToColor = vec4(0.0, 0.0, 1.0, 1.0); //Outside color\n"
+			"\n"
+			"  vec2 u_v2HalfShapeSizePx = u_texsize/2.0 - vec2(u_fHalfBorderThickness);\n"
+			"  vec2 v_v2CenteredPos = (gl_FragCoord.xy - u_texsize.xy / 2.0 - coord);\n"
+			"\n"
+			"  float fDist = RectSDF(v_v2CenteredPos, u_v2HalfShapeSizePx, u_fRadiusPx - u_fHalfBorderThickness);\n"
+			"  if (u_fHalfBorderThickness > 0.0) {\n"
+			"    if (fDist < 0.0) {\n"
+			"      v4ToColor = u_v4FillColor;\n"
+			"    }\n"
+			"    fDist = abs(fDist) - u_fHalfBorderThickness;\n"
+			"  } else {\n"
+			"    v4FromColor = u_v4FillColor;\n"
+			"  }\n"
+			"  float fBlendAmount = clamp(fDist + 0.5, 0.0, 1.0);\n"
+			"  vec4 c = mix(v4FromColor, v4ToColor, fBlendAmount);"
+			"\n"
+			"  // final color\n"
+			"  if ( c == vec4(0.0,0.0,0.0,0.0) ) discard; else\n"
+			"  gl_FragColor = c;\n"
+			"  //gl_FragColor = vec4(vec3(fBlendAmount), 1.0);\n"
+			"  //gl_FragColor = vec4(vec3(abs(dist) / (2.0 * corner)), 1.0);\n"
+			"}\n";
+
+		const bool use_texture_rect = !ps->psglx->has_texture_non_power_of_two;
+		const char *sampler_type = (use_texture_rect ? "sampler2DRect": "sampler2D");
+		const char *texture_func = (use_texture_rect ? "texture2DRect": "texture2D");
+		char *extension = NULL;
+		if (use_texture_rect) {
+			mstrextend(&extension, "#extension GL_ARB_texture_rectangle : "
+			                       "require\n");
+		}
+		if (!extension) {
+			extension = strdup("");
+		}
+
+		if (!glx_init_frag_shader_corners(&ps->psglx->round_passes[0], 0,
+									FRAG_SHADER_PREFIX, FRAG_SHADER_ROUND_CORNERS_0,
+									extension, sampler_type, texture_func)) {
+
+										log_error("Failed to create rounded corners fragment shader PRE.");
+										setlocale(LC_NUMERIC, lc_numeric_old);
+										free(lc_numeric_old);
+										free(extension);
+										return false;
+									}
+
+		if (!glx_init_frag_shader_corners(&ps->psglx->round_passes[1], 1,
+									FRAG_SHADER_PREFIX, FRAG_SHADER_ROUND_CORNERS_1,
+									extension, sampler_type, texture_func)) {
+
+										log_error("Failed to create rounded corners fragment shader POST.");
+										setlocale(LC_NUMERIC, lc_numeric_old);
+										free(lc_numeric_old);
+										free(extension);
+										return false;
+									}
+
+		free(extension);
+
+		// Restore LC_NUMERIC
+		setlocale(LC_NUMERIC, lc_numeric_old);
+		free(lc_numeric_old);
+	}
+
+	gl_check_err();
+
+	return true;
+}
+
+/**
  * Load a GLSL main program from shader strings.
  */
 bool glx_load_prog_main(const char *vshader_str, const char *fshader_str,
@@ -448,8 +689,116 @@
 }
 
 /**
+ * @brief Release binding of a texture.
+ */
+void glx_release_texture(session_t *ps attr_unused, glx_texture_t **pptex) {
+	glx_texture_t *ptex = *pptex;
+	// Release binding
+	if (ptex->texture) {
+		//log_info("Deleting texture wh(%d %d)", ptex->width, ptex->height);
+		glBindTexture(ptex->target, 0);
+		glDeleteTextures(1, &ptex->texture);
+	}
+	free(ptex);
+	*pptex = NULL;
+
+	gl_check_err();
+}
+
+/**
  * Bind a X pixmap to an OpenGL texture.
  */
+bool glx_bind_texture(session_t *ps attr_unused, glx_texture_t **pptex,
+				int x, int y, int width attr_unused, int height attr_unused, bool repeat attr_unused) {
+	if (ps->o.backend != BKEND_GLX && ps->o.backend != BKEND_XR_GLX_HYBRID)
+		return true;
+
+	glx_texture_t *ptex = *pptex;
+
+	//log_trace("Copying xy(%d %d) wh(%d %d)", x, y, width, height);
+
+	// Release texture if parameters are inconsistent
+	if (ptex && ptex->texture &&
+		(ptex->width != width || ptex->height != height)) {
+		//log_info("Windows size changed old_wh(%d %d) new_wh(%d %d)", ptex->width, ptex->height, width, height);
+		glx_release_texture(ps, &ptex);
+	}
+
+	// Allocate structure
+	if (!ptex) {
+		static const glx_texture_t GLX_TEX_DEF = {
+		    .texture = 0,
+		    .glpixmap = 0,
+		    .pixmap = 0,
+		    .target = 0,
+		    .width = 0,
+		    .height = 0,
+		    .y_inverted = false,
+		};
+
+		ptex = cmalloc(glx_texture_t);
+		memcpy(ptex, &GLX_TEX_DEF, sizeof(glx_texture_t));
+		*pptex = ptex;
+
+		ptex->width = width;
+		ptex->height = height;
+		ptex->target = GL_TEXTURE_RECTANGLE;
+		if (ps->psglx->has_texture_non_power_of_two)
+			ptex->target = GL_TEXTURE_2D;
+	}
+
+	// Create texture
+	if (!ptex->texture) {
+		//log_info("Generating texture for xy(%d %d) wh(%d %d)", x, y, width, height);
+		GLuint texture = 0;
+		glGenTextures(1, &texture);
+
+		if (texture) {
+			glEnable(ptex->target);
+			glBindTexture(ptex->target, texture);
+
+			glTexParameteri(ptex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+			glTexParameteri(ptex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+			if (repeat) {
+				glTexParameteri(ptex->target, GL_TEXTURE_WRAP_S, GL_REPEAT);
+				glTexParameteri(ptex->target, GL_TEXTURE_WRAP_T, GL_REPEAT);
+			} else {
+				glTexParameteri(ptex->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+				glTexParameteri(ptex->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+			}
+
+			glTexImage2D(ptex->target, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
+
+			glBindTexture(ptex->target, 0);
+			//glDisable(ptex->target);
+		}
+
+		ptex->texture = texture;
+	}
+	if (!ptex->texture) {
+		log_error("Failed to allocate texture.");
+		return false;
+	}
+
+	// Read destination pixels into a texture
+	glEnable(ptex->target);
+	glBindTexture(ptex->target, ptex->texture);
+	if (width > 0 && height > 0)
+		glCopyTexSubImage2D(ptex->target, 0, 0, 0, x, ps->root_height - y - height, width, height);
+
+	// Cleanup
+	glBindTexture(ptex->target, 0);
+	glDisable(ptex->target);
+
+	gl_check_err();
+
+	return true;
+}
+
+
+/**
+ * Bind a X pixmap to an OpenGL texture.
+ */
 bool glx_bind_pixmap(session_t *ps, glx_texture_t **pptex, xcb_pixmap_t pixmap, int width,
                      int height, bool repeat, const struct glx_fbconfig_info *fbcfg) {
 	if (ps->o.backend != BKEND_GLX && ps->o.backend != BKEND_XR_GLX_HYBRID)
@@ -887,6 +1236,335 @@
 	return ret;
 }
 
+
+bool glx_read_border_pixel(session_t *ps, struct managed_win *w, int x, int y, int width attr_unused, int height, float *ppixel)
+{
+	if (!ppixel) return false;
+
+	// First try bottom left corner
+	auto openglx = x;
+	auto opengly = ps->root_height-height-y;
+
+	// bottom left corner is out of bounds
+	// use top border line instead
+	if (openglx < 0 && opengly < 0) {
+		//openglx = x + width;
+		opengly += height-1;
+	}
+
+	// Invert Y-axis so we can query border color from texture (0,0)
+	glReadPixels((openglx < 0) ? 0 : openglx, (opengly < 0) ? 0 : opengly, 1, 1,
+				GL_RGBA, GL_FLOAT, (void*)&w->border_col[0]);
+
+	//log_warn("xy(%d, %d), glxy(%d %d) wh(%d %d), border_col(%.2f, %.2f, %.2f, %.2f)",
+	//	x, y, openglx, opengly, width, height,
+	//	(float)w->border_col[0], (float)w->border_col[1], (float)w->border_col[2], (float)w->border_col[3]);
+	
+	gl_check_err();
+	
+	return true;
+}
+
+bool glx_round_corners_dst0(session_t *ps, struct managed_win *w, const glx_texture_t *ptex attr_unused, int shader_idx,
+				int dx, int dy, int width, int height, float z, float cr,
+				const region_t *reg_tgt attr_unused, glx_blur_cache_t *pbc) {
+
+	assert(shader_idx >= 0 && shader_idx <= 1);
+	assert(ps->psglx->round_passes[0].prog);
+	assert(ps->psglx->round_passes[1].prog);
+	const bool have_scissors = glIsEnabled(GL_SCISSOR_TEST);
+	const bool have_stencil = glIsEnabled(GL_STENCIL_TEST);
+	bool ret = false;
+
+	//log_warn("dxy(%d, %d) wh(%d %d) rwh(%d %d) bw(%d)",
+	//	dx, dy, width, height, ps->root_width, ps->root_height, w->g.border_width);
+
+	if (w->g.border_width >= 1 && w->border_col[0] == -1.0) {
+		glx_read_border_pixel(ps, w, dx, dy, width, height, &w->border_col[0]);
+	}
+
+	// Calculate copy region size
+	glx_blur_cache_t ibc = {.width = 0, .height = 0};
+	if (!pbc)
+		pbc = &ibc;
+
+	int mdx = dx, mdy = dy, mwidth = width, mheight = height;
+	// log_trace("%d, %d, %d, %d", mdx, mdy, mwidth, mheight);
+
+	GLenum tex_tgt = GL_TEXTURE_RECTANGLE;
+	if (ps->psglx->has_texture_non_power_of_two)
+		tex_tgt = GL_TEXTURE_2D;
+
+	// Free textures if size inconsistency discovered
+	if (mwidth != pbc->width || mheight != pbc->height)
+		free_glx_bc_resize(ps, pbc);
+
+	// Generate FBO and textures if needed
+	if (!pbc->textures[0])
+		pbc->textures[0] = glx_gen_texture(tex_tgt, mwidth, mheight);
+	GLuint tex_scr = pbc->textures[0];
+
+	pbc->width = mwidth;
+	pbc->height = mheight;
+
+	if (!tex_scr) {
+		log_error("Failed to allocate texture.");
+		goto glx_round_corners_dst_end;
+	}
+
+	// Read destination pixels into a texture
+	glEnable(tex_tgt);
+	glBindTexture(tex_tgt, tex_scr);
+	glx_copy_region_to_tex(ps, tex_tgt, mdx, mdy, mdx, mdy, mwidth, mheight);
+
+	// Texture scaling factor
+	GLfloat texfac_x = 1.0f, texfac_y = 1.0f;
+	if (tex_tgt == GL_TEXTURE_2D) {
+		texfac_x /= (GLfloat)mwidth;
+		texfac_y /= (GLfloat)mheight;
+	}
+
+	// Paint it back
+	{
+		glDisable(GL_STENCIL_TEST);
+		glDisable(GL_SCISSOR_TEST);
+	}
+
+	{
+		const glx_round_pass_t *ppass = &ps->psglx->round_passes[shader_idx];
+		assert(ppass->prog);
+
+		assert(tex_scr);
+
+		glActiveTexture(GL_TEXTURE1); 
+		glBindTexture(tex_tgt, tex_scr);
+
+		// If caller specified a texture use it as source
+		if (ptex) {
+			glActiveTexture(GL_TEXTURE0);
+			glBindTexture(ptex->target, ptex->texture);
+		} else {
+			glActiveTexture(GL_TEXTURE0); 
+			glBindTexture(tex_tgt, tex_scr);
+		}
+
+		glBindFramebuffer(GL_FRAMEBUFFER, 0);
+		glDrawBuffer(GL_BACK);
+		if (have_scissors)
+			glEnable(GL_SCISSOR_TEST);
+		if (have_stencil)
+			glEnable(GL_STENCIL_TEST);
+
+
+		// Our shader generates a transparent mid section
+		// with opaque corners copied from the background texture
+		// We must use blending to get the window pixesl to appear
+		//glDisable(GL_BLEND);
+		glEnable(GL_BLEND);
+		glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+
+		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+
+		glUseProgram(ppass->prog);
+
+		if (ppass->unifm_tex_scr >= 0)
+			glUniform1i(ppass->unifm_tex_scr, (GLint)0);
+		if (ppass->unifm_tex_wnd >= 0)
+			glUniform1i(ppass->unifm_tex_wnd, (GLint)1);
+
+		if (ppass->unifm_radius >= 0)
+			glUniform1f(ppass->unifm_radius, cr);
+		if (ppass->unifm_texcoord >= 0)
+			glUniform2f(ppass->unifm_texcoord, (float)dx, (float)dy);
+		if (ppass->unifm_texsize >= 0)
+			glUniform2f(ppass->unifm_texsize, (float)mwidth, (float)mheight);
+		if (ppass->unifm_borderw >= 0)
+			glUniform1f(ppass->unifm_borderw, (w->border_col[0] != -1.) ? w->g.border_width : 0);
+		if (ppass->unifm_borderc >= 0)
+			glUniform4fv(ppass->unifm_borderc, 1, (GLfloat *)&w->border_col[0]);
+		if (ppass->unifm_resolution >= 0)
+			glUniform2f(ppass->unifm_resolution, (float)ps->root_width, (float)ps->root_height);
+
+		// Painting
+		{
+			P_PAINTREG_START(crect) {
+				// XXX explain these variables
+				auto rx = (GLfloat)(crect.x1 - dx);
+				auto ry = (GLfloat)(crect.y1 - dy);
+				auto rxe = rx + (GLfloat)(crect.x2 - crect.x1);
+				auto rye = ry + (GLfloat)(crect.y2 - crect.y1);
+				// Rectangle textures have [0-w] [0-h] while 2D texture has [0-1]
+				// [0-1] Thanks to amonakov for pointing out!
+				if (GL_TEXTURE_2D == tex_tgt) {
+					rx = rx / (GLfloat)width;
+					ry = ry / (GLfloat)height;
+					rxe = rxe / (GLfloat)width;
+					rye = rye / (GLfloat)height;
+				}
+				auto rdx = (GLfloat)crect.x1;
+				auto rdy = (GLfloat)(ps->root_height - crect.y1);
+				auto rdxe = (GLfloat)rdx + (GLfloat)(crect.x2 - crect.x1);
+				auto rdye = (GLfloat)rdy - (GLfloat)(crect.y2 - crect.y1);
+
+				// Invert Y if needed, this may not work as expected, though. I
+				// don't have such a FBConfig to test with.
+				//if (ptex && !ptex->y_inverted) {
+				{
+					ry = 1.0f - ry;
+					rye = 1.0f - rye;
+				}
+
+				//log_trace("Rect %d (i:%d): %f, %f, %f, %f -> %f, %f, %f, %f",
+				//	ri ,ptex ? ptex->y_inverted : -1, rx, ry, rxe, rye, rdx, rdy, rdxe, rdye);
+
+				glTexCoord2f(rx, ry);
+				glVertex3f(rdx, rdy, z);
+
+				glTexCoord2f(rxe, ry);
+				glVertex3f(rdxe, rdy, z);
+
+				glTexCoord2f(rxe, rye);
+				glVertex3f(rdxe, rdye, z);
+
+				glTexCoord2f(rx, rye);
+				glVertex3f(rdx, rdye, z);
+
+			}
+			P_PAINTREG_END();
+		}
+
+		glUseProgram(0);
+		glDisable(GL_BLEND);
+	}
+
+	ret = true;
+
+glx_round_corners_dst_end:
+	glBindFramebuffer(GL_FRAMEBUFFER, 0);
+	glBindTexture(tex_tgt, 0);
+	glDisable(tex_tgt);
+	if (have_scissors)
+		glEnable(GL_SCISSOR_TEST);
+	if (have_stencil)
+		glEnable(GL_STENCIL_TEST);
+
+	if (&ibc == pbc) {
+		free_glx_bc(ps, pbc);
+	}
+
+	gl_check_err();
+
+	return ret;
+}
+
+bool glx_round_corners_dst1(session_t *ps, struct managed_win *w, const glx_texture_t *ptex, int shader_idx,
+				int dx, int dy, int width, int height, float z, float cr,
+				const region_t *reg_tgt attr_unused, glx_blur_cache_t *pbc attr_unused) {
+
+	assert(shader_idx >= 0 && shader_idx <= 1);
+	assert(ps->psglx->round_passes[0].prog);
+	assert(ps->psglx->round_passes[1].prog);
+	bool ret = false;
+	
+	if (w->g.border_width >= 1 && w->border_col[0] == -1.0) {
+		glx_read_border_pixel(ps, w, dx, dy, width, height, &w->border_col[0]);
+	}
+
+	{
+		const glx_round_pass_t *ppass = &ps->psglx->round_passes[shader_idx];
+		assert(ppass->prog);
+
+		// If caller specified a texture use it as source
+		if (ptex) {
+			glActiveTexture(GL_TEXTURE0);
+			glBindTexture(ptex->target, ptex->texture);
+		}
+
+		glEnable(GL_BLEND);
+		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+		glUseProgram(ppass->prog);
+
+		if (ppass->unifm_tex_scr >= 0)
+			glUniform1i(ppass->unifm_tex_scr, (GLint)0);
+		// We have no GL_TEXTURE1 here so just pass the default
+		if (ppass->unifm_tex_wnd >= 0)
+			glUniform1i(ppass->unifm_tex_wnd, (GLint)0);
+
+		if (ppass->unifm_radius >= 0)
+			glUniform1f(ppass->unifm_radius, cr);
+		if (ppass->unifm_texcoord >= 0)
+			glUniform2f(ppass->unifm_texcoord, (float)dx, (float)dy);
+		if (ppass->unifm_texsize >= 0)
+			glUniform2f(ppass->unifm_texsize, (float)width, (float)height);
+		if (ppass->unifm_borderw >= 0)
+			glUniform1f(ppass->unifm_borderw, (w->border_col[0] != -1.) ? w->g.border_width : 0);
+		if (ppass->unifm_borderc >= 0)
+			glUniform4fv(ppass->unifm_borderc, 1, (GLfloat *)&w->border_col[0]);
+		if (ppass->unifm_resolution >= 0)
+			glUniform2f(ppass->unifm_resolution, (float)ps->root_width, (float)ps->root_height);
+
+		// Painting
+		{
+			P_PAINTREG_START(crect) {
+				// XXX explain these variables
+				auto rx = (GLfloat)(crect.x1 - dx);
+				auto ry = (GLfloat)(crect.y1 - dy);
+				auto rxe = rx + (GLfloat)(crect.x2 - crect.x1);
+				auto rye = ry + (GLfloat)(crect.y2 - crect.y1);
+				// Rectangle textures have [0-w] [0-h] while 2D texture has [0-1]
+				// [0-1] Thanks to amonakov for pointing out!
+				if (GL_TEXTURE_2D == ptex->target) {
+					rx = rx / (GLfloat)width;
+					ry = ry / (GLfloat)height;
+					rxe = rxe / (GLfloat)width;
+					rye = rye / (GLfloat)height;
+				}
+				auto rdx = (GLfloat)crect.x1;
+				auto rdy = (GLfloat)(ps->root_height - crect.y1);
+				auto rdxe = (GLfloat)rdx + (GLfloat)(crect.x2 - crect.x1);
+				auto rdye = (GLfloat)rdy - (GLfloat)(crect.y2 - crect.y1);
+
+				// Invert Y if needed, this may not work as expected, though. I
+				// don't have such a FBConfig to test with.
+				//if (ptex && !ptex->y_inverted) {
+				{
+					ry = 1.0f - ry;
+					rye = 1.0f - rye;
+				}
+
+				//log_trace("Rect %d (i:%d): %f, %f, %f, %f -> %f, %f, %f, %f",
+				//	ri ,ptex ? ptex->y_inverted : -1, rx, ry, rxe, rye, rdx, rdy, rdxe, rdye);
+
+				glTexCoord2f(rx, ry);
+				glVertex3f(rdx, rdy, z);
+
+				glTexCoord2f(rxe, ry);
+				glVertex3f(rdxe, rdy, z);
+
+				glTexCoord2f(rxe, rye);
+				glVertex3f(rdxe, rdye, z);
+
+				glTexCoord2f(rx, rye);
+				glVertex3f(rdx, rdye, z);
+
+			}
+			P_PAINTREG_END();
+		}
+
+		glUseProgram(0);
+		glDisable(GL_BLEND);
+	}
+
+	ret = true;
+
+	//glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+	gl_check_err();
+
+	return ret;
+}
+
 bool glx_dim_dst(session_t *ps, int dx, int dy, int width, int height, int z,
                  GLfloat factor, const region_t *reg_tgt) {
 	// It's possible to dim in glx_render(), but it would be over-complicated
@@ -920,9 +1598,9 @@
 /**
  * @brief Render a region with texture data.
  */
-bool glx_render(session_t *ps, const glx_texture_t *ptex, int x, int y, int dx, int dy,
-                int width, int height, int z, double opacity, bool argb, bool neg,
-                const region_t *reg_tgt, const glx_prog_main_t *pprogram) {
+bool glx_render(session_t *ps, struct managed_win *w attr_unused, const glx_texture_t *ptex,
+				int x, int y, int dx, int dy, int width, int height, int z, double opacity, bool argb,
+				bool neg, int cr attr_unused, const region_t *reg_tgt, const glx_prog_main_t *pprogram) {
 	if (!ptex || !ptex->texture) {
 		log_error("Missing texture.");
 		return false;
@@ -936,7 +1614,7 @@
 	glEnable(ptex->target);
 
 	// Enable blending if needed
-	if (opacity < 1.0 || argb) {
+	if (opacity < 1.0 || argb || cr > 0) {
 
 		glEnable(GL_BLEND);
 
--- old/src/opengl.h
+++ new/src/opengl.h
@@ -40,6 +40,30 @@
 	GLint unifm_factor_center;
 } glx_blur_pass_t;
 
+typedef struct {
+	/// Fragment shader for rounded corners.
+	GLuint frag_shader;
+	/// GLSL program for rounded corners.
+	GLuint prog;
+	/// Location of uniform "radius" in rounded-corners GLSL program.
+	GLint unifm_radius;
+	/// Location of uniform "texcoord" in rounded-corners GLSL program.
+	GLint unifm_texcoord;
+	/// Location of uniform "texsize" in rounded-corners GLSL program.
+	GLint unifm_texsize;
+	/// Location of uniform "borderw" in rounded-corners GLSL program.
+	GLint unifm_borderw;
+	/// Location of uniform "borderc" in rounded-corners GLSL program.
+	GLint unifm_borderc;
+	/// Location of uniform "resolution" in rounded-corners GLSL program.
+	GLint unifm_resolution;
+	/// Location of uniform "texture_scr" in rounded-corners GLSL program.
+	GLint unifm_tex_scr;
+	/// Location of uniform "texture_wnd" in rounded-corners GLSL program.
+	GLint unifm_tex_wnd;
+
+} glx_round_pass_t;
+
 /// Structure containing GLX-dependent data for a session.
 typedef struct glx_session {
 	// === OpenGL related ===
@@ -50,6 +74,7 @@
 	/// Current GLX Z value.
 	int z;
 	glx_blur_pass_t *blur_passes;
+	glx_round_pass_t *round_passes;
 } glx_session_t;
 
 /// @brief Wrapper of a binded GLX texture.
@@ -69,8 +94,8 @@
 bool glx_dim_dst(session_t *ps, int dx, int dy, int width, int height, int z,
                  GLfloat factor, const region_t *reg_tgt);
 
-bool glx_render(session_t *ps, const glx_texture_t *ptex, int x, int y, int dx, int dy,
-                int width, int height, int z, double opacity, bool argb, bool neg,
+bool glx_render(session_t *ps, struct managed_win *w, const glx_texture_t *ptex, int x, int y, int dx, int dy,
+                int width, int height, int z, double opacity, bool argb, bool neg, int cr,
                 const region_t *reg_tgt, const glx_prog_main_t *pprogram);
 
 bool glx_init(session_t *ps, bool need_render);
@@ -81,6 +106,8 @@
 
 bool glx_init_blur(session_t *ps);
 
+bool glx_init_rounded_corners(session_t *ps);
+
 #ifdef CONFIG_OPENGL
 bool glx_load_prog_main(const char *vshader_str, const char *fshader_str,
                         glx_prog_main_t *pprogram);
@@ -91,6 +118,11 @@
 
 void glx_release_pixmap(session_t *ps, glx_texture_t *ptex);
 
+bool glx_bind_texture(session_t *ps, glx_texture_t **pptex,
+					int x, int y, int width, int height, bool repeat);
+
+void glx_release_texture(session_t *ps, glx_texture_t **ptex);
+
 void glx_paint_pre(session_t *ps, region_t *preg) attr_nonnull(1, 2);
 
 /**
@@ -105,6 +137,14 @@
 bool glx_blur_dst(session_t *ps, int dx, int dy, int width, int height, float z,
                   GLfloat factor_center, const region_t *reg_tgt, glx_blur_cache_t *pbc);
 
+bool glx_round_corners_dst0(session_t *ps, struct managed_win *w, const glx_texture_t *ptex, int shader_idx,
+					int dx, int dy, int width, int height, float z, float cr,
+					const region_t *reg_tgt, glx_blur_cache_t *pbc);
+
+bool glx_round_corners_dst1(session_t *ps, struct managed_win *w, const glx_texture_t *ptex, int shader_idx,
+					int dx, int dy, int width, int height, float z, float cr,
+					const region_t *reg_tgt, glx_blur_cache_t *pbc);	  
+
 GLuint glx_create_shader(GLenum shader_type, const char *shader_str);
 
 GLuint glx_create_program(const GLuint *const shaders, int nshaders);
@@ -206,6 +246,8 @@
 	free_paint_glx(ps, &w->shadow_paint);
 #ifdef CONFIG_OPENGL
 	free_glx_bc(ps, &w->glx_blur_cache);
+	free_glx_bc(ps, &w->glx_round_cache);
+	free_texture(ps, &w->glx_texture_bg);
 	free(w->paint.fbcfg);
 #endif
 }
--- old/src/options.c
+++ new/src/options.c
@@ -114,6 +114,12 @@
 	    "--active-opacity opacity\n"
 	    "  Default opacity for active windows. (0.0 - 1.0)\n"
 	    "\n"
+	    "--corner-radius value\n"
+	    "  Round the corners of windows. (defaults to 0)\n"
+	    "\n"
+	    "--rounded-corners-exclude condition\n"
+	    "  Exclude conditions for rounded corners.\n"
+	    "\n"
 	    "--mark-wmwin-focused\n"
 	    "  Try to detect WM windows and mark them as active.\n"
 	    "\n"
@@ -437,6 +443,8 @@
     {"blur-method", required_argument, NULL, 328},
     {"blur-size", required_argument, NULL, 329},
     {"blur-deviation", required_argument, NULL, 330},
+    {"corner-radius", required_argument, NULL, 331},
+    {"rounded-corners-exclude", required_argument, NULL, 332},
     {"experimental-backends", no_argument, NULL, 733},
     {"monitor-repaint", no_argument, NULL, 800},
     {"diagnostics", no_argument, NULL, 801},
@@ -842,6 +850,8 @@
 			opt->blur_deviation = atof(optarg);
 			break;
 
+        case 331: opt->corner_radius = atoi(optarg); break;
+        case 332: condlst_add(&opt->rounded_corners_blacklist, optarg); break;
 		P_CASEBOOL(733, experimental_backends);
 		P_CASEBOOL(800, monitor_repaint);
 		case 801: opt->print_diagnostics = true; break;
--- old/src/picom.c
+++ new/src/picom.c
@@ -694,8 +694,20 @@
 			w->frame_opacity = 1.0;
 		}
 
+		// The below moved to it's own function:
+		// `win_determine_rounded_corners` (win.c)
+		/*
+		// Don't round full screen windows & excluded windows
+		if ((w && win_is_fullscreen(ps, w)) || 
+			c2_match(ps, w, ps->o.rounded_corners_blacklist, NULL)) {
+			w->corner_radius = 0;
+		} else {
+			w->corner_radius = ps->o.corner_radius;
+		}
+		*/
+
 		// Update window mode
-		w->mode = win_calc_mode(w);
+		w->mode = win_calc_mode(ps, w);
 
 		// Destroy all reg_ignore above when frame opaque state changes on
 		// SOLID mode
@@ -775,11 +787,10 @@
 		    ps->o.transparent_clipping) {
 			// w->mode == WMODE_SOLID or WMODE_FRAME_TRANS
 			region_t *tmp = rc_region_new();
-			if (w->mode == WMODE_SOLID) {
-				*tmp = win_get_bounding_shape_global_by_val(w);
-			} else {
-				// w->mode == WMODE_FRAME_TRANS
-				win_get_region_noframe_local(w, tmp);
+			if (w->frame_opacity == 1)
+				*tmp = win_get_bounding_shape_global_by_val(w, false);
+			else {
+				win_get_region_noframe_local(w, tmp, false);
 				pixman_region32_intersect(tmp, tmp, &w->bounding_shape);
 				pixman_region32_translate(tmp, w->g.x, w->g.y);
 			}
@@ -1852,6 +1863,7 @@
 	      c2_list_postprocess(ps, ps->o.blur_background_blacklist) &&
 	      c2_list_postprocess(ps, ps->o.invert_color_list) &&
 	      c2_list_postprocess(ps, ps->o.opacity_rules) &&
+	      c2_list_postprocess(ps, ps->o.rounded_corners_blacklist) &&
 	      c2_list_postprocess(ps, ps->o.focus_blacklist))) {
 		log_error("Post-processing of conditionals failed, some of your rules "
 		          "might not work");
@@ -2227,6 +2239,7 @@
 	free_wincondlst(&ps->o.opacity_rules);
 	free_wincondlst(&ps->o.paint_blacklist);
 	free_wincondlst(&ps->o.unredir_if_possible_blacklist);
+	free_wincondlst(&ps->o.rounded_corners_blacklist);
 
 	// Free tracked atom list
 	{
--- old/src/render.c
+++ new/src/render.c
@@ -186,28 +186,138 @@
 	ppaint->pixmap = XCB_NONE;
 }
 
-void render(session_t *ps, int x, int y, int dx, int dy, int wid, int hei, double opacity,
-            bool argb, bool neg, xcb_render_picture_t pict, glx_texture_t *ptex,
-            const region_t *reg_paint, const glx_prog_main_t *pprogram) {
+uint32_t
+make_circle(int cx, int cy, int radius, uint32_t max_ntraps, xcb_render_trapezoid_t traps[]) {
+	uint32_t n = 0, k = 0;
+	int y1, y2;
+	double w;
+	while (k < max_ntraps) {
+		y1 = (int)(-radius * cos(M_PI * k / max_ntraps));
+		traps[n].top = (cy + y1) << 16;
+		traps[n].left.p1.y = (cy + y1) << 16;
+		traps[n].right.p1.y = (cy + y1) << 16;
+		w = sqrt(radius * radius - y1 * y1) * 65536;
+		traps[n].left.p1.x = (int)((cx << 16) - w);
+		traps[n].right.p1.x = (int)((cx << 16) + w);
+
+		do {
+			k++;
+			y2 = (int)(-radius * cos(M_PI * k / max_ntraps));
+		} while (y1 == y2);
+
+		traps[n].bottom = (cy + y2) << 16;
+		traps[n].left.p2.y = (cy + y2) << 16;
+		traps[n].right.p2.y = (cy + y2) << 16;
+		w = sqrt(radius * radius - y2 * y2) * 65536;
+		traps[n].left.p2.x = (int)((cx << 16) - w);
+		traps[n].right.p2.x = (int)((cx << 16) + w);
+		n++;
+	}
+	return n;
+}
+
+uint32_t make_rectangle(int x, int y, int wid, int hei, xcb_render_trapezoid_t traps[]) {
+	traps[0].top = y << 16;
+	traps[0].left.p1.y = y << 16;
+	traps[0].left.p1.x = x << 16;
+	traps[0].left.p2.y = (y + hei) << 16;
+	traps[0].left.p2.x = x << 16;
+	traps[0].bottom = (y + hei) << 16;
+	traps[0].right.p1.x = (x + wid) << 16;
+	traps[0].right.p1.y = y << 16;
+	traps[0].right.p2.x = (x + wid) << 16;
+	traps[0].right.p2.y = (y + hei) << 16;
+	return 1;
+}
+
+uint32_t make_rounded_window_shape(xcb_render_trapezoid_t traps[], uint32_t max_ntraps, int cr, int wid, int hei)
+{
+    uint32_t n = make_circle(cr, cr, cr, max_ntraps, traps);
+    n += make_circle(wid - cr, cr, cr, max_ntraps, traps + n);
+    n += make_circle(wid - cr, hei - cr, cr, max_ntraps, traps + n);
+    n += make_circle(cr, hei - cr, cr, max_ntraps, traps + n);
+    n += make_rectangle(0, cr, cr, hei - 2 * cr, traps + n);
+    n += make_rectangle(cr, 0, wid - 2 * cr, cr, traps + n);
+    n += make_rectangle(wid - cr, cr, cr, hei - 2 * cr, traps + n);
+    n += make_rectangle(cr, hei - cr, wid - 2 * cr, cr, traps + n);
+    n += make_rectangle(cr, cr, wid - 2 * cr, hei - 2 * cr,
+                        traps + n);
+    return n;
+}
+
+void render(session_t *ps, struct managed_win *w, int x, int y, int dx, int dy, int wid, int hei, int fullwid, int fullhei, double opacity,
+            bool argb, bool neg, int cr, xcb_render_picture_t pict, glx_texture_t *ptex,
+            const region_t *reg_paint, const glx_prog_main_t *pprogram, clip_t *clip) {
 	switch (ps->o.backend) {
 	case BKEND_XRENDER:
 	case BKEND_XR_GLX_HYBRID: {
 		auto alpha_step = (int)(opacity * MAX_ALPHA);
 		xcb_render_picture_t alpha_pict = ps->alpha_picts[alpha_step];
 		if (alpha_step != 0) {
-			uint8_t op = ((!argb && !alpha_pict) ? XCB_RENDER_PICT_OP_SRC
-			                                     : XCB_RENDER_PICT_OP_OVER);
-			xcb_render_composite(
-			    ps->c, op, pict, alpha_pict, ps->tgt_buffer.pict,
-			    to_i16_checked(x), to_i16_checked(y), 0, 0, to_i16_checked(dx),
-			    to_i16_checked(dy), to_u16_checked(wid), to_u16_checked(hei));
+			if (cr) {
+				//log_warn("f(%d, %d) wh(%d %d) xy(%d %d) dxy(%d %d)", fullwid, fullhei, wid, hei, x, y, dx, dy);
+				xcb_render_picture_t p_tmp = x_create_picture_with_standard(
+				    ps->c, ps->root, fullwid, fullhei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+				xcb_render_color_t trans = {
+				    .red = 0, .blue = 0, .green = 0, .alpha = 0};
+				const xcb_rectangle_t rect = {.x = 0,
+				                              .y = 0,
+				                              .width = to_u16_checked(fullwid),
+				                              .height = to_u16_checked(fullhei)};
+				xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC,
+				                           p_tmp, trans, 1, &rect);
+
+				uint32_t max_ntraps = to_u32_checked(cr);
+				xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+
+				uint32_t n = make_rounded_window_shape(traps, max_ntraps, cr, fullwid, fullhei);
+
+				xcb_render_trapezoids(
+					ps->c, XCB_RENDER_PICT_OP_OVER, alpha_pict, p_tmp,
+					x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8),
+					0, 0, n, traps);
+
+				xcb_render_composite(
+				    ps->c, XCB_RENDER_PICT_OP_OVER, pict, p_tmp,
+				    ps->tgt_buffer.pict, to_i16_checked(x), to_i16_checked(y),
+				    to_i16_checked(x), to_i16_checked(y), to_i16_checked(dx), to_i16_checked(dy),
+				    to_u16_checked(wid), to_u16_checked(hei));
+
+				xcb_render_free_picture(ps->c, p_tmp);
+
+			} else {
+                xcb_render_picture_t p_tmp = alpha_pict;
+                if(clip){
+                    p_tmp =  x_create_picture_with_standard(ps->c, ps->root, wid, hei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+
+                    xcb_render_color_t black = {.red = 255, .blue = 255, .green = 255, .alpha = 255};
+                    const xcb_rectangle_t rect = {.x = 0, .y = 0, .width = to_u16_checked(wid), .height = to_u16_checked(hei)};
+                    xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC, p_tmp, black, 1, &rect);
+                    if(alpha_pict) {
+                        xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_SRC, alpha_pict, XCB_NONE, p_tmp, 0, 0, 0, 0, 0, 0, to_u16_checked(wid), to_u16_checked(hei));
+                    }
+                    xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_OUT_REVERSE, clip->pict, XCB_NONE, p_tmp, 0, 0, 0, 0, to_i16_checked(clip->x),  to_i16_checked(clip->y), to_u16_checked(wid), to_u16_checked(hei));
+                }
+				uint8_t op =
+				    ((!argb && !alpha_pict && !clip) ? XCB_RENDER_PICT_OP_SRC
+				                            : XCB_RENDER_PICT_OP_OVER);
+
+				xcb_render_composite(
+				    ps->c, op, pict, p_tmp, ps->tgt_buffer.pict,
+				    to_i16_checked(x), to_i16_checked(y), 0, 0,
+				    to_i16_checked(dx), to_i16_checked(dy),
+				    to_u16_checked(wid), to_u16_checked(hei));
+                if(clip){
+                    xcb_render_free_picture(ps->c, p_tmp);
+                }
+			}
 		}
 		break;
 	}
 #ifdef CONFIG_OPENGL
 	case BKEND_GLX:
-		glx_render(ps, ptex, x, y, dx, dy, wid, hei, ps->psglx->z, opacity, argb,
-		           neg, reg_paint, pprogram);
+		glx_render(ps, w, ptex, x, y, dx, dy, wid, hei, ps->psglx->z, opacity, argb,
+		           neg, cr, reg_paint, pprogram);
 		ps->psglx->z += 1;
 		break;
 #endif
@@ -222,21 +332,24 @@
 }
 
 static inline void
-paint_region(session_t *ps, const struct managed_win *w, int x, int y, int wid, int hei,
+paint_region(session_t *ps, struct managed_win *w, int x, int y, int wid, int hei,
              double opacity, const region_t *reg_paint, xcb_render_picture_t pict) {
 	const int dx = (w ? w->g.x : 0) + x;
 	const int dy = (w ? w->g.y : 0) + y;
+    const int fullwid = w ? w->widthb : 0;
+    const int fullhei = w ? w-> heightb : 0;
 	const bool argb = (w && (win_has_alpha(w) || ps->o.force_win_blend));
 	const bool neg = (w && w->invert_color);
 
-	render(ps, x, y, dx, dy, wid, hei, opacity, argb, neg, pict,
-	       (w ? w->paint.ptex : ps->root_tile_paint.ptex), reg_paint,
+	render(ps, w, x, y, dx, dy, wid, hei, fullwid, fullhei, opacity, argb, neg,
+			(w ? w->corner_radius : 0),
+			pict, (w ? w->paint.ptex : ps->root_tile_paint.ptex), reg_paint,
 #ifdef CONFIG_OPENGL
 	       w ? &ps->glx_prog_win : NULL
 #else
 	       NULL
 #endif
-	);
+	, XCB_NONE);
 }
 
 /**
@@ -260,6 +373,44 @@
 }
 
 /**
+ * Rounde the corners of a window.
+ * Applies a fragment shader to discard corners
+ * 
+ */
+static inline void
+win_round_corners(session_t *ps, struct managed_win *w, const glx_texture_t *ptex, int shader_idx,
+				float cr, xcb_render_picture_t tgt_buffer attr_unused, const region_t *reg_paint) {
+	const int16_t x = w->g.x;
+	const int16_t y = w->g.y;
+	const auto wid = to_u16_checked(w->widthb);
+	const auto hei = to_u16_checked(w->heightb);
+
+	//log_debug("x:%d y:%d w:%d h:%d", x, y, wid, hei);
+
+	switch (ps->o.backend) {
+	case BKEND_XRENDER:
+	case BKEND_XR_GLX_HYBRID: {
+		// XRender method is implemented inside render()
+	} break;
+#ifdef CONFIG_OPENGL
+	case BKEND_GLX:
+		if (shader_idx == 1) {
+			glx_round_corners_dst1(ps, w, ptex, shader_idx, x, y, wid, hei,
+								(float)ps->psglx->z - 0.5f, cr, reg_paint, &w->glx_round_cache);
+		} else {
+			glx_round_corners_dst0(ps, w, ptex, shader_idx, x, y, wid, hei,
+								(float)ps->psglx->z - 0.5f, cr, reg_paint, &w->glx_round_cache);
+		}
+		break;
+#endif
+	default: assert(0);
+	}
+#ifndef CONFIG_OPENGL
+	(void)reg_paint;
+#endif
+}
+
+/**
  * Paint a window itself and dim it if asked.
  */
 void paint_one(session_t *ps, struct managed_win *w, const region_t *reg_paint) {
@@ -302,7 +453,7 @@
 		log_error("Window %#010x is missing painting data.", w->base.id);
 		return;
 	}
-
+	
 	const int x = w->g.x;
 	const int y = w->g.y;
 	const uint16_t wid = to_u16_checked(w->widthb);
@@ -612,9 +763,29 @@
 		return;
 	}
 
-	render(ps, 0, 0, w->g.x + w->shadow_dx, w->g.y + w->shadow_dy, w->shadow_width,
-	       w->shadow_height, w->shadow_opacity, true, false, w->shadow_paint.pict,
-	       w->shadow_paint.ptex, reg_paint, NULL);
+    xcb_render_picture_t td = XCB_NONE;
+    if (w->corner_radius) {
+            uint32_t max_ntraps = to_u32_checked(w->corner_radius);
+            xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+            uint32_t n = make_rounded_window_shape(traps, max_ntraps, w->corner_radius, w->widthb, w->heightb);
+
+            td = x_create_picture_with_standard(ps->c, ps->root, w->widthb, w->heightb, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+            xcb_render_color_t trans = {.red = 0, .blue = 0, .green = 0, .alpha = 0};
+            const xcb_rectangle_t rect = {.x = 0, .y = 0, .width = to_u16_checked(w->widthb), .height = to_u16_checked(w->heightb)};
+            xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC, td, trans, 1, &rect);
+
+            auto solid = solid_picture(ps->c, ps->root, false, 1, 0, 0, 0);
+            xcb_render_trapezoids(ps->c, XCB_RENDER_PICT_OP_OVER, solid, td, x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8), 0, 0, n, traps);
+            xcb_render_free_picture(ps->c, solid);
+        }
+
+    clip_t clip = { .pict = td, -(w->shadow_dx), .y = -(w->shadow_dy) };
+	render(ps, w, 0, 0, w->g.x + w->shadow_dx, w->g.y + w->shadow_dy, w->shadow_width,
+	       w->shadow_height, w->widthb, w->heightb, w->shadow_opacity, true, false, 0, w->shadow_paint.pict,
+	       w->shadow_paint.ptex, reg_paint, NULL, w->corner_radius ? &clip : NULL);
+    if(td){
+        xcb_render_free_picture(ps->c, td);
+    }
 }
 
 /**
@@ -634,7 +805,7 @@
  */
 static bool xr_blur_dst(session_t *ps, xcb_render_picture_t tgt_buffer, int16_t x, int16_t y,
                         uint16_t wid, uint16_t hei, struct x_convolution_kernel **blur_kerns,
-                        int nkernels, const region_t *reg_clip) {
+                        int nkernels, const region_t *reg_clip, xcb_render_picture_t rounded) {
 	assert(blur_kerns);
 	assert(blur_kerns[0]);
 
@@ -679,7 +850,7 @@
 	}
 
 	if (src_pict != tgt_buffer)
-		xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_SRC, src_pict, XCB_NONE,
+		xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_OVER, src_pict, rounded,
 		                     tgt_buffer, 0, 0, 0, 0, x, y, wid, hei);
 
 	free_picture(ps->c, &tmp_picture);
@@ -697,6 +868,7 @@
 	const int16_t y = w->g.y;
 	const auto wid = to_u16_checked(w->widthb);
 	const auto hei = to_u16_checked(w->heightb);
+	const int cr = (w ? w->corner_radius : 0);
 
 	double factor_center = 1.0;
 	// Adjust blur strength according to window opacity, to make it appear
@@ -728,21 +900,42 @@
 			                            &ps->blur_kerns_cache[i]);
 		}
 
+        xcb_render_picture_t td = XCB_NONE;
+        if (cr) {
+            uint32_t max_ntraps = to_u32_checked(cr);
+            xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+            uint32_t n = make_rounded_window_shape(traps, max_ntraps, cr, wid, hei);
+
+            td = x_create_picture_with_standard(ps->c, ps->root, wid, hei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+            xcb_render_color_t trans = {.red = 0, .blue = 0, .green = 0, .alpha = 0};
+            const xcb_rectangle_t rect = {.x = 0, .y = 0, .width = to_u16_checked(wid), .height = to_u16_checked(hei)};
+            xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC, td, trans, 1, &rect);
+
+            auto solid = solid_picture(ps->c, ps->root, false, 1, 0, 0, 0);
+
+            xcb_render_trapezoids(ps->c, XCB_RENDER_PICT_OP_OVER, solid, td, x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8), 0, 0, n, traps);
+            xcb_render_free_picture(ps->c, solid);
+        }
+
 		// Minimize the region we try to blur, if the window itself is not
 		// opaque, only the frame is.
-		region_t reg_blur = win_get_bounding_shape_global_by_val(w);
+		region_t reg_blur = win_get_bounding_shape_global_by_val(w, true);
 		if (w->mode == WMODE_FRAME_TRANS && !ps->o.force_win_blend) {
 			region_t reg_noframe;
 			pixman_region32_init(&reg_noframe);
-			win_get_region_noframe_local(w, &reg_noframe);
+			win_get_region_noframe_local(w, &reg_noframe, true);
 			pixman_region32_translate(&reg_noframe, w->g.x, w->g.y);
 			pixman_region32_subtract(&reg_blur, &reg_blur, &reg_noframe);
 			pixman_region32_fini(&reg_noframe);
 		}
+        
 		// Translate global coordinates to local ones
 		pixman_region32_translate(&reg_blur, -x, -y);
 		xr_blur_dst(ps, tgt_buffer, x, y, wid, hei, ps->blur_kerns_cache,
-		            ps->o.blur_kernel_count, &reg_blur);
+		            ps->o.blur_kernel_count, &reg_blur, td);
+        if(td){
+            xcb_render_free_picture(ps->c, td);
+        }
 		pixman_region32_clear(&reg_blur);
 	} break;
 #ifdef CONFIG_OPENGL
@@ -851,7 +1044,9 @@
 	//
 	// Whether this is beneficial is to be determined XXX
 	for (auto w = t; w; w = w->prev_trans) {
-		region_t bshape = win_get_bounding_shape_global_by_val(w);
+		region_t bshape_no_corners = win_get_bounding_shape_global_by_val(w, false);
+		region_t bshape_corners = win_get_bounding_shape_global_by_val(w, true);
+
 		// Painting shadow
 		if (w->shadow) {
 			// Lazy shadow building
@@ -880,7 +1075,7 @@
 			// saving GPU power and handling shaped windows (XXX
 			// unconfirmed)
 			if (!ps->o.wintype_option[w->window_type].full_shadow)
-				pixman_region32_subtract(&reg_tmp, &reg_tmp, &bshape);
+				pixman_region32_subtract(&reg_tmp, &reg_tmp, &bshape_no_corners);
 
 			if (ps->o.xinerama_shadow_crop && w->xinerama_scr >= 0 &&
 			    w->xinerama_scr < ps->xinerama_nscrs)
@@ -907,11 +1102,22 @@
 		// Remember, reg_ignore is the union of all windows above the current
 		// window.
 		pixman_region32_subtract(&reg_tmp, &region, w->reg_ignore);
-		pixman_region32_intersect(&reg_tmp, &reg_tmp, &bshape);
-		pixman_region32_fini(&bshape);
+		pixman_region32_intersect(&reg_tmp, &reg_tmp, &bshape_corners);
+		pixman_region32_fini(&bshape_corners);
+        pixman_region32_fini(&bshape_no_corners);
 
 		if (pixman_region32_not_empty(&reg_tmp)) {
 			set_tgt_clip(ps, &reg_tmp);
+
+			// If rounded corners backup the region first
+			if (w->corner_radius > 0) {
+				const int16_t x = w->g.x;
+				const int16_t y = w->g.y;
+				const auto wid = to_u16_checked(w->widthb);
+				const auto hei = to_u16_checked(w->heightb);
+				glx_bind_texture(ps, &w->glx_texture_bg, x, y, wid, hei, false);
+			}
+			
 			// Blur window background
 			if (w->blur_background &&
 			    (w->mode == WMODE_TRANS ||
@@ -921,6 +1127,11 @@
 
 			// Painting the window
 			paint_one(ps, w, &reg_tmp);
+
+			// Round window corners
+			if (w->corner_radius > 0) {
+				win_round_corners(ps, w, w->glx_texture_bg, 0,
+						(float)w->corner_radius, ps->tgt_buffer.pict, &reg_tmp); }
 		}
 	}
 
@@ -1009,8 +1220,8 @@
 		else
 			glFlush();
 		glXWaitX();
-		glx_render(ps, ps->tgt_buffer.ptex, 0, 0, 0, 0, ps->root_width,
-		           ps->root_height, 0, 1.0, false, false, &region, NULL);
+		glx_render(ps, t, ps->tgt_buffer.ptex, 0, 0, 0, 0, ps->root_width,
+		           ps->root_height, 0, 1.0, false, false, 0, &region, NULL);
 		// falls through
 	case BKEND_GLX: glXSwapBuffers(ps->dpy, get_tgt_window(ps)); break;
 #endif
@@ -1173,6 +1384,18 @@
 			log_error("Failed to create shadow picture.");
 			return false;
 		}
+	}
+
+	// Initialize our rounded corners fragment shader
+	if (ps->o.corner_radius > 0 && ps->o.backend == BKEND_GLX) {
+#ifdef CONFIG_OPENGL
+		if (!glx_init_rounded_corners(ps)) {
+			log_error("Failed to init rounded corners shader.");
+			return false;
+		}
+#else
+    assert(false);
+#endif
 	}
 	return true;
 }
--- old/src/render.h
+++ new/src/render.h
@@ -25,9 +25,16 @@
 #endif
 } paint_t;
 
-void render(session_t *ps, int x, int y, int dx, int dy, int w, int h, double opacity,
-            bool argb, bool neg, xcb_render_picture_t pict, glx_texture_t *ptex,
-            const region_t *reg_paint, const glx_prog_main_t *pprogram);
+
+typedef struct clip {
+    xcb_render_picture_t pict;
+    int x;
+    int y;
+} clip_t;
+
+void render(session_t *ps, struct managed_win *, int x, int y, int dx, int dy, int w, int h, int fullw, int fullh, double opacity,
+            bool argb, bool neg, int cr, xcb_render_picture_t pict, glx_texture_t *ptex,
+            const region_t *reg_paint, const glx_prog_main_t *pprogram, clip_t *clip);
 void paint_one(session_t *ps, struct managed_win *w, const region_t *reg_paint);
 
 void paint_all(session_t *ps, struct managed_win *const t, bool ignore_damage);
--- old/src/win.c
+++ new/src/win.c
@@ -58,6 +58,17 @@
 
 /// Generate a "return by value" function, from a function that returns the
 /// region via a region_t pointer argument.
+/// Function signature has to be (win *, region_t *, bool)
+#define gen_by_val_corners(fun)                                                                  \
+	region_t fun##_by_val(const struct managed_win *w, bool include_corners) {                             \
+		region_t ret;                                                            \
+		pixman_region32_init(&ret);                                              \
+		fun(w, &ret, include_corners);                                                            \
+		return ret;                                                              \
+	}
+
+/// Generate a "return by value" function, from a function that returns the
+/// region via a region_t pointer argument.
 /// Function signature has to be (win *, region_t *)
 #define gen_by_val(fun)                                                                  \
 	region_t fun##_by_val(const struct managed_win *w) {                             \
@@ -173,16 +184,18 @@
 /**
  * Get a rectangular region a window occupies, excluding shadow.
  */
-static void win_get_region_local(const struct managed_win *w, region_t *res) {
+static void win_get_region_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	assert(w->widthb >= 0 && w->heightb >= 0);
 	pixman_region32_fini(res);
 	pixman_region32_init_rect(res, 0, 0, (uint)w->widthb, (uint)w->heightb);
+
+    if(!include_corners) win_region_remove_corners(w, res);
 }
 
 /**
  * Get a rectangular region a window occupies, excluding frame and shadow.
  */
-void win_get_region_noframe_local(const struct managed_win *w, region_t *res) {
+void win_get_region_noframe_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	const margin_t extents = win_calc_frame_extents(w);
 
 	int x = extents.left;
@@ -193,10 +206,11 @@
 	pixman_region32_fini(res);
 	if (width > 0 && height > 0) {
 		pixman_region32_init_rect(res, x, y, (uint)width, (uint)height);
+        if(!include_corners) win_region_remove_corners(w, res);
 	}
 }
 
-void win_get_region_frame_local(const struct managed_win *w, region_t *res) {
+void win_get_region_frame_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	const margin_t extents = win_calc_frame_extents(w);
 	auto outer_width = extents.left + extents.right + w->g.width;
 	auto outer_height = extents.top + extents.bottom + w->g.height;
@@ -219,10 +233,11 @@
 	region_t reg_win;
 	pixman_region32_init_rects(&reg_win, (rect_t[]){0, 0, outer_width, outer_height}, 1);
 	pixman_region32_intersect(res, &reg_win, res);
+    if(!include_corners) win_region_remove_corners(w, res);
 	pixman_region32_fini(&reg_win);
 }
 
-gen_by_val(win_get_region_frame_local);
+gen_by_val_corners(win_get_region_frame_local);
 
 /**
  * Add a window to damaged area.
@@ -538,11 +553,15 @@
 	       w->client_pictfmt->direct.alpha_mask;
 }
 
-winmode_t win_calc_mode(const struct managed_win *w) {
+winmode_t win_calc_mode(session_t *ps, const struct managed_win *w) {
 	if (w->opacity < 1.0) {
 		return WMODE_TRANS;
 	}
 
+	if (ps->o.backend == BKEND_GLX && w->corner_radius > 0) {
+		return WMODE_TRANS;
+	}
+
 	if (win_has_alpha(w)) {
 		if (w->client_win == XCB_NONE) {
 			// This is a window not managed by the WM, and it has alpha,
@@ -876,6 +895,28 @@
 }
 
 /**
+ * Determine if a window should have rounded corners.
+ */
+static void win_determine_rounded_corners(session_t *ps, struct managed_win *w) {
+	if (w->a.map_state != XCB_MAP_STATE_VIEWABLE || ps->o.corner_radius == 0)
+		return;
+
+	// Don't round full screen windows & excluded windows
+	if ((w && win_is_fullscreen(ps, w)) || 
+		c2_match(ps, w, ps->o.rounded_corners_blacklist, NULL)) {
+		w->corner_radius = 0;
+		//log_warn("xy(%d %d) wh(%d %d) will NOT round corners", w->g.x, w->g.y, w->widthb, w->heightb);
+	} else {
+		w->corner_radius = ps->o.corner_radius;
+		//log_warn("xy(%d %d) wh(%d %d) will round corners", w->g.x, w->g.y, w->widthb, w->heightb);
+		// HACK: we reset this so we can query the color once
+		// we query the color in glx_round_corners_dst0 using glReadPixels
+		//w->border_col = { -1., -1, -1, -1 };
+		w->border_col[0] = w->border_col[1] = w->border_col[2] = w->border_col[3] = -1.0;
+	}
+}
+
+/**
  * Update window opacity according to opacity rules.
  */
 void win_update_opacity_rule(session_t *ps, struct managed_win *w) {
@@ -908,6 +949,7 @@
 	win_determine_shadow(ps, w);
 	win_determine_invert_color(ps, w);
 	win_determine_blur_background(ps, w);
+	win_determine_rounded_corners(ps, w);
 	win_update_opacity_rule(ps, w);
 	if (w->a.map_state == XCB_MAP_STATE_VIEWABLE)
 		w->paint_excluded = c2_match(ps, w, ps->o.paint_blacklist, NULL);
@@ -1227,6 +1269,8 @@
 	    // Initialized during paint
 	    .paint = PAINT_INIT,
 	    .shadow_paint = PAINT_INIT,
+
+	    .corner_radius = 0,
 	};
 
 	assert(!w->destroyed);
@@ -1516,7 +1560,7 @@
 
 	pixman_region32_clear(&w->bounding_shape);
 	// Start with the window rectangular region
-	win_get_region_local(w, &w->bounding_shape);
+	win_get_region_local(w, &w->bounding_shape, true);
 
 	// Only request for a bounding region if the window is shaped
 	// (while loop is used to avoid goto, not an actual loop)
@@ -2065,7 +2109,7 @@
 	}
 
 	// Update window mode here to check for ARGB windows
-	w->mode = win_calc_mode(w);
+	w->mode = win_calc_mode(ps, w);
 
 	// Detect client window here instead of in add_win() as the client
 	// window should have been prepared at this point
@@ -2102,6 +2146,7 @@
 	          w->opacity, w->opacity_target);
 
 	win_determine_blur_background(ps, w);
+	win_determine_rounded_corners(ps, w);
 
 	// Cannot set w->ever_damaged = false here, since window mapping could be
 	// delayed, so a damage event might have already arrived before this function
--- old/src/win.h
+++ new/src/win.h
@@ -202,6 +202,10 @@
 	/// Last window opacity value set by the rules.
 	double opacity_set;
 
+	/// Corner radius
+	int corner_radius;
+	float border_col[4];
+
 	// Fading-related members
 	/// Override value of window fade state. Set by D-Bus method calls.
 	switch_t fade_force;
@@ -249,6 +253,9 @@
 #ifdef CONFIG_OPENGL
 	/// Textures and FBO background blur use.
 	glx_blur_cache_t glx_blur_cache;
+	glx_blur_cache_t glx_round_cache;
+	/// Background texture of the window
+	glx_texture_t *glx_texture_bg;
 #endif
 };
 
@@ -279,7 +286,7 @@
 void win_release_images(struct backend_base *base, struct managed_win *w);
 int win_update_name(session_t *ps, struct managed_win *w);
 int win_get_role(session_t *ps, struct managed_win *w);
-winmode_t attr_pure win_calc_mode(const struct managed_win *w);
+winmode_t attr_pure win_calc_mode(session_t *ps, const struct managed_win *w);
 void win_set_shadow_force(session_t *ps, struct managed_win *w, switch_t val);
 void win_set_fade_force(struct managed_win *w, switch_t val);
 void win_set_focused_force(session_t *ps, struct managed_win *w, switch_t val);
@@ -357,12 +364,12 @@
  *
  * Return region in global coordinates.
  */
-void win_get_region_noframe_local(const struct managed_win *w, region_t *);
+void win_get_region_noframe_local(const struct managed_win *w, region_t *, bool include_corners);
 
 /// Get the region for the frame of the window
-void win_get_region_frame_local(const struct managed_win *w, region_t *res);
+void win_get_region_frame_local(const struct managed_win *w, region_t *res, bool include_corners);
 /// Get the region for the frame of the window, by value
-region_t win_get_region_frame_local_by_val(const struct managed_win *w);
+region_t win_get_region_frame_local_by_val(const struct managed_win *w, bool include_corners);
 /**
  * Retrieve frame extents from a window.
  */
@@ -438,10 +445,26 @@
 /// Free all resources in a struct win
 void free_win_res(session_t *ps, struct managed_win *w);
 
-static inline region_t win_get_bounding_shape_global_by_val(struct managed_win *w) {
+static inline void win_region_remove_corners(const struct managed_win *w, region_t *res) {
+    region_t corners;
+    pixman_region32_init_rects(
+        &corners,
+        (rect_t[]){
+            {.x1 = 0, .y1 = 0, .x2 = w->corner_radius, .y2 = w->corner_radius},
+            {.x1 = 0, .y1 = w->heightb-w->corner_radius, .x2 = w->corner_radius, .y2 = w->heightb},
+            {.x1 = w->widthb-w->corner_radius, .y1 = 0, .x2 = w->widthb, .y2 = w->corner_radius},
+            {.x1 = w->widthb-w->corner_radius, .y1 = w->heightb-w->corner_radius, .x2 = w->widthb, .y2 = w->heightb},
+        },
+        4);
+    pixman_region32_subtract(res, res, &corners);
+    pixman_region32_fini(&corners);
+}
+
+static inline region_t win_get_bounding_shape_global_by_val(struct managed_win *w, bool include_corners) {
 	region_t ret;
 	pixman_region32_init(&ret);
 	pixman_region32_copy(&ret, &w->bounding_shape);
+    if(!include_corners) win_region_remove_corners(w, &ret);
 	pixman_region32_translate(&ret, w->g.x, w->g.y);
 	return ret;
 }
--- old/src/x.c
+++ new/src/x.c
@@ -168,6 +168,15 @@
 	return x_get_visual_for_pictfmt(g_pictfmts, pictfmt->id);
 }
 
+xcb_render_pictformat_t
+x_get_pictfmt_for_standard(xcb_connection_t *c, xcb_pict_standard_t std) {
+	x_get_server_pictfmts(c);
+
+	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, std);
+
+	return pictfmt->id;
+}
+
 int x_get_visual_depth(xcb_connection_t *c, xcb_visualid_t visual) {
 	auto setup = xcb_get_setup(c);
 	for (auto screen = xcb_setup_roots_iterator(setup); screen.rem;
@@ -229,6 +238,17 @@
 	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, standard);
 	assert(pictfmt);
 	return x_create_picture_with_pictfmt_and_pixmap(c, pictfmt, pixmap, valuemask, attr);
+}
+
+xcb_render_picture_t
+x_create_picture_with_standard(xcb_connection_t *c, xcb_drawable_t d, int w, int h,
+                               xcb_pict_standard_t standard, uint32_t valuemask,
+                               const xcb_render_create_picture_value_list_t *attr) {
+	x_get_server_pictfmts(c);
+
+	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, standard);
+	assert(pictfmt);
+	return x_create_picture_with_pictfmt(c, d, w, h, pictfmt, valuemask, attr);
 }
 
 /**
--- old/src/x.h
+++ new/src/x.h
@@ -172,6 +172,12 @@
                                           const xcb_render_create_picture_value_list_t *attr)
     attr_nonnull(1);
 
+xcb_render_picture_t
+x_create_picture_with_standard(xcb_connection_t *c, xcb_drawable_t d, int w, int h,
+                               xcb_pict_standard_t standard, uint32_t valuemask,
+                               const xcb_render_create_picture_value_list_t *attr)
+    attr_nonnull(1);
+
 /**
  * Create an picture.
  */
@@ -260,6 +266,9 @@
 struct xvisual_info x_get_visual_info(xcb_connection_t *c, xcb_visualid_t visual);
 
 xcb_visualid_t x_get_visual_for_standard(xcb_connection_t *c, xcb_pict_standard_t std);
+
+xcb_render_pictformat_t
+x_get_pictfmt_for_standard(xcb_connection_t *c, xcb_pict_standard_t std);
 
 xcb_screen_t *x_screen_of_display(xcb_connection_t *c, int screen);
 
