--- old/man/picom.1.asciidoc
+++ new/man/picom.1.asciidoc
@@ -106,6 +106,12 @@
 *--inactive-dim* 'VALUE'::
 	Dim inactive windows. (0.0 - 1.0, defaults to 0.0)
 
+*--corner-radius* 'VALUE'::
+	Round the corners of windows. (defaults to 0).
+
+*--rounded-corners-exclude* 'CONDITION'::
+	Exclude conditions for rounded corners.
+
 *--mark-wmwin-focused*::
 	Try to detect WM windows (a non-override-redirect window with no child that has 'WM_STATE') and mark them as active.
 
--- old/src/backend/backend.c
+++ new/src/backend/backend.c
@@ -168,7 +168,7 @@
 
 		// The bounding shape of the window, in global/target coordinates
 		// reminder: bounding shape contains the WM frame
-		auto reg_bound = win_get_bounding_shape_global_by_val(w);
+		auto reg_bound = win_get_bounding_shape_global_by_val(w, true);
 
 		// The clip region for the current window, in global/target coordinates
 		// reg_paint_in_bound \in reg_paint
@@ -227,7 +227,7 @@
 				assert(ps->o.blur_background_frame);
 				assert(real_win_mode == WMODE_FRAME_TRANS);
 
-				auto reg_blur = win_get_region_frame_local_by_val(w);
+				auto reg_blur = win_get_region_frame_local_by_val(w, true);
 				pixman_region32_translate(&reg_blur, w->g.x, w->g.y);
 				// make sure reg_blur \in reg_paint
 				pixman_region32_intersect(&reg_blur, &reg_blur, &reg_paint);
@@ -357,7 +357,7 @@
 				    &reg_visible_local, (double[]){dim_opacity});
 			}
 			if (w->frame_opacity != 1) {
-				auto reg_frame = win_get_region_frame_local_by_val(w);
+				auto reg_frame = win_get_region_frame_local_by_val(w, true);
 				ps->backend_data->ops->image_op(
 				    ps->backend_data, IMAGE_OP_APPLY_ALPHA, new_img, &reg_frame,
 				    &reg_visible_local, (double[]){w->frame_opacity});
--- old/src/config.c
+++ new/src/config.c
@@ -561,6 +561,8 @@
 
 	    .track_wdata = false,
 	    .track_leader = false,
+
+	    .rounded_corners_blacklist = NULL
 	};
 
 	char *ret = NULL;
--- old/src/config.h
+++ new/src/config.h
@@ -239,6 +239,10 @@
 	// Make transparent windows clip other windows, instead of blending on top of
 	// them
 	bool transparent_clipping;
+	// === Rounded corners related ===
+	int corner_radius;
+	/// Rounded corners blacklist. A linked list of conditions.
+	c2_lptr_t *rounded_corners_blacklist;
 } options_t;
 
 extern const char *const BACKEND_STRS[NUM_BKEND + 1];
--- old/src/config_libconfig.c
+++ new/src/config_libconfig.c
@@ -367,6 +278,10 @@
 	// --active_opacity
 	if (config_lookup_float(&cfg, "active-opacity", &dval))
 		opt->active_opacity = normalize_d(dval);
+	// --corner-radius
+	config_lookup_int(&cfg, "corner-radius", &opt->corner_radius);
+	// --rounded-corners-exclude
+	parse_cfg_condlst(&cfg, &opt->rounded_corners_blacklist, "rounded-corners-exclude");
 	// -e (frame_opacity)
 	config_lookup_float(&cfg, "frame-opacity", &opt->frame_opacity);
 	// -c (shadow_enable)
--- old/src/event.c
+++ new/src/event.c
@@ -618,14 +618,14 @@
 	 * if we attempt to rebuild border_size
 	 */
 	// Mark the old border_size as damaged
-	region_t tmp = win_get_bounding_shape_global_by_val(w);
+	region_t tmp = win_get_bounding_shape_global_by_val(w, true);
 	add_damage(ps, &tmp);
 	pixman_region32_fini(&tmp);
 
 	win_update_bounding_shape(ps, w);
 
 	// Mark the new border_size as damaged
-	tmp = win_get_bounding_shape_global_by_val(w);
+	tmp = win_get_bounding_shape_global_by_val(w, true);
 	add_damage(ps, &tmp);
 	pixman_region32_fini(&tmp);
 
--- old/src/options.c
+++ new/src/options.c
@@ -114,6 +114,12 @@
	    "--active-opacity opacity\n"
	    "  Default opacity for active windows. (0.0 - 1.0)\n"
	    "\n"
+	    "--corner-radius value\n"
+	    "  Round the corners of windows. (defaults to 0)\n"
+	    "\n"
+	    "--rounded-corners-exclude condition\n"
+	    "  Exclude conditions for rounded corners.\n"
+	    "\n"
	    "--mark-wmwin-focused\n"
	    "  Try to detect WM windows and mark them as active.\n"
	    "\n"
@@ -437,6 +443,8 @@
    {"blur-method", required_argument, NULL, 328},
    {"blur-size", required_argument, NULL, 329},
    {"blur-deviation", required_argument, NULL, 330},
+   {"corner-radius", required_argument, NULL, 331},
+   {"rounded-corners-exclude", required_argument, NULL, 332},
    {"experimental-backends", no_argument, NULL, 733},
    {"monitor-repaint", no_argument, NULL, 800},
    {"diagnostics", no_argument, NULL, 801},
@@ -842,6 +850,8 @@
			opt->blur_deviation = atof(optarg);
			break;

+       case 331: opt->corner_radius = atoi(optarg); break;
+       case 332: condlst_add(&opt->rounded_corners_blacklist, optarg); break;
		P_CASEBOOL(733, experimental_backends);
		P_CASEBOOL(800, monitor_repaint);
		case 801: opt->print_diagnostics = true; break;
--- old/src/picom.c
+++ new/src/picom.c
@@ -472,6 +472,8 @@
 			w->frame_opacity = 1.0;
 		}
 
+		w->corner_radius = ps->o.corner_radius;
+
 		// Update window mode
 		w->mode = win_calc_mode(w);
 
@@ -553,11 +560,10 @@
 		    ps->o.transparent_clipping) {
 			// w->mode == WMODE_SOLID or WMODE_FRAME_TRANS
 			region_t *tmp = rc_region_new();
-			if (w->mode == WMODE_SOLID) {
-				*tmp = win_get_bounding_shape_global_by_val(w);
-			} else {
-				// w->mode == WMODE_FRAME_TRANS
-				win_get_region_noframe_local(w, tmp);
+			if (w->frame_opacity == 1)
+				*tmp = win_get_bounding_shape_global_by_val(w, false);
+			else {
+				win_get_region_noframe_local(w, tmp, false);
 				pixman_region32_intersect(tmp, tmp, &w->bounding_shape);
 				pixman_region32_translate(tmp, w->g.x, w->g.y);
 			}
@@ -1824,6 +1828,7 @@
 	      c2_list_postprocess(ps, ps->o.blur_background_blacklist) &&
 	      c2_list_postprocess(ps, ps->o.invert_color_list) &&
 	      c2_list_postprocess(ps, ps->o.opacity_rules) &&
+	      c2_list_postprocess(ps, ps->o.rounded_corners_blacklist) &&
 	      c2_list_postprocess(ps, ps->o.focus_blacklist))) {
 		log_error("Post-processing of conditionals failed, some of your rules "
 		          "might not work");
@@ -2197,6 +2168,7 @@
 	free_wincondlst(&ps->o.opacity_rules);
 	free_wincondlst(&ps->o.paint_blacklist);
 	free_wincondlst(&ps->o.unredir_if_possible_blacklist);
+	free_wincondlst(&ps->o.rounded_corners_blacklist);
 
 	// Free tracked atom list
 	{
--- old/src/render.c
+++ new/src/render.c
@@ -186,8 +186,67 @@
 	ppaint->pixmap = XCB_NONE;
 }
 
-void render(session_t *ps, int x, int y, int dx, int dy, int wid, int hei, double opacity,
-            bool argb, bool neg, xcb_render_picture_t pict, glx_texture_t *ptex,
+uint32_t
+make_circle(int cx, int cy, int radius, uint32_t max_ntraps, xcb_render_trapezoid_t traps[]) {
+	uint32_t n = 0, k = 0;
+	int y1, y2;
+	double w;
+	while (k < max_ntraps) {
+		y1 = (int)(-radius * cos(M_PI * k / max_ntraps));
+		traps[n].top = (cy + y1) << 16;
+		traps[n].left.p1.y = (cy + y1) << 16;
+		traps[n].right.p1.y = (cy + y1) << 16;
+		w = sqrt(radius * radius - y1 * y1) * 65536;
+		traps[n].left.p1.x = (int)((cx << 16) - w);
+		traps[n].right.p1.x = (int)((cx << 16) + w);
+
+		do {
+			k++;
+			y2 = (int)(-radius * cos(M_PI * k / max_ntraps));
+		} while (y1 == y2);
+
+		traps[n].bottom = (cy + y2) << 16;
+		traps[n].left.p2.y = (cy + y2) << 16;
+		traps[n].right.p2.y = (cy + y2) << 16;
+		w = sqrt(radius * radius - y2 * y2) * 65536;
+		traps[n].left.p2.x = (int)((cx << 16) - w);
+		traps[n].right.p2.x = (int)((cx << 16) + w);
+		n++;
+	}
+	return n;
+}
+
+uint32_t make_rectangle(int x, int y, int wid, int hei, xcb_render_trapezoid_t traps[]) {
+	traps[0].top = y << 16;
+	traps[0].left.p1.y = y << 16;
+	traps[0].left.p1.x = x << 16;
+	traps[0].left.p2.y = (y + hei) << 16;
+	traps[0].left.p2.x = x << 16;
+	traps[0].bottom = (y + hei) << 16;
+	traps[0].right.p1.x = (x + wid) << 16;
+	traps[0].right.p1.y = y << 16;
+	traps[0].right.p2.x = (x + wid) << 16;
+	traps[0].right.p2.y = (y + hei) << 16;
+	return 1;
+}
+
+uint32_t make_rounded_window_shape(xcb_render_trapezoid_t traps[], uint32_t max_ntraps, int cr, int wid, int hei)
+{
+    uint32_t n = make_circle(cr, cr, cr, max_ntraps, traps);
+    n += make_circle(wid - cr, cr, cr, max_ntraps, traps + n);
+    n += make_circle(wid - cr, hei - cr, cr, max_ntraps, traps + n);
+    n += make_circle(cr, hei - cr, cr, max_ntraps, traps + n);
+    n += make_rectangle(0, cr, cr, hei - 2 * cr, traps + n);
+    n += make_rectangle(cr, 0, wid - 2 * cr, cr, traps + n);
+    n += make_rectangle(wid - cr, cr, cr, hei - 2 * cr, traps + n);
+    n += make_rectangle(cr, hei - cr, wid - 2 * cr, cr, traps + n);
+    n += make_rectangle(cr, cr, wid - 2 * cr, hei - 2 * cr,
+                        traps + n);
+    return n;
+}
+
+void render(session_t *ps, int x, int y, int dx, int dy, int wid, int hei, int fullwid, int fullhei, double opacity,
+            bool argb, bool neg, int cr, xcb_render_picture_t pict, glx_texture_t *ptex,
             const region_t *reg_paint, const glx_prog_main_t *pprogram) {
 	switch (ps->o.backend) {
 	case BKEND_XRENDER:
@@ -195,12 +254,46 @@
 		auto alpha_step = (int)(opacity * MAX_ALPHA);
 		xcb_render_picture_t alpha_pict = ps->alpha_picts[alpha_step];
 		if (alpha_step != 0) {
-			uint8_t op = ((!argb && !alpha_pict) ? XCB_RENDER_PICT_OP_SRC
-			                                     : XCB_RENDER_PICT_OP_OVER);
-			xcb_render_composite(
-			    ps->c, op, pict, alpha_pict, ps->tgt_buffer.pict,
-			    to_i16_checked(x), to_i16_checked(y), 0, 0, to_i16_checked(dx),
-			    to_i16_checked(dy), to_u16_checked(wid), to_u16_checked(hei));
+			if (cr) {
+				xcb_render_picture_t p_tmp = x_create_picture_with_standard(
+				    ps->c, ps->root, fullwid, fullhei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+				xcb_render_color_t trans = {
+				    .red = 0, .blue = 0, .green = 0, .alpha = 0};
+				const xcb_rectangle_t rect = {.x = 0,
+				                              .y = 0,
+				                              .width = to_u16_checked(fullwid),
+				                              .height = to_u16_checked(fullhei)};
+				xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC,
+				                           p_tmp, trans, 1, &rect);
+
+				uint32_t max_ntraps = to_u32_checked(cr);
+				xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+
+                uint32_t n = make_rounded_window_shape(traps, max_ntraps, cr, fullwid, fullhei);
+
+                xcb_render_trapezoids(
+                    ps->c, XCB_RENDER_PICT_OP_OVER, alpha_pict, p_tmp,
+                    x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8),
+                    0, 0, n, traps);
+
+				xcb_render_composite(
+				    ps->c, XCB_RENDER_PICT_OP_OVER, pict, p_tmp,
+				    ps->tgt_buffer.pict, to_i16_checked(x), to_i16_checked(y),
+				    to_i16_checked(x), to_i16_checked(y), to_i16_checked(dx), to_i16_checked(dy),
+				    to_u16_checked(wid), to_u16_checked(hei));
+
+				xcb_render_free_picture(ps->c, p_tmp);
+
+			} else {
+				uint8_t op =
+				    ((!argb && !alpha_pict) ? XCB_RENDER_PICT_OP_SRC
+				                            : XCB_RENDER_PICT_OP_OVER);
+				xcb_render_composite(
+				    ps->c, op, pict, alpha_pict, ps->tgt_buffer.pict,
+				    to_i16_checked(x), to_i16_checked(y), 0, 0,
+				    to_i16_checked(dx), to_i16_checked(dy),
+				    to_u16_checked(wid), to_u16_checked(hei));
+			}
 		}
 		break;
 	}
@@ -226,11 +319,13 @@
              double opacity, const region_t *reg_paint, xcb_render_picture_t pict) {
 	const int dx = (w ? w->g.x : 0) + x;
 	const int dy = (w ? w->g.y : 0) + y;
+    const int fullwid = w ? w->widthb : 0;
+    const int fullhei = w ? w-> heightb : 0;
 	const bool argb = (w && (win_has_alpha(w) || ps->o.force_win_blend));
 	const bool neg = (w && w->invert_color);
 
-	render(ps, x, y, dx, dy, wid, hei, opacity, argb, neg, pict,
-	       (w ? w->paint.ptex : ps->root_tile_paint.ptex), reg_paint,
+    render(ps, x, y, dx, dy, wid, hei, fullwid, fullhei, opacity, argb, neg, (w && !win_is_fullscreen(ps, w) && !c2_match(ps, w, ps->o.rounded_corners_blacklist, NULL) ? w->corner_radius : 0),
+	       pict, (w ? w->paint.ptex : ps->root_tile_paint.ptex), reg_paint,
 #ifdef CONFIG_OPENGL
 	       w ? &ps->glx_prog_win : NULL
 #else
@@ -613,7 +708,7 @@
 	}
 
 	render(ps, 0, 0, w->g.x + w->shadow_dx, w->g.y + w->shadow_dy, w->shadow_width,
-	       w->shadow_height, w->shadow_opacity, true, false, w->shadow_paint.pict,
+	       w->shadow_height, w->widthb, w->heightb, w->shadow_opacity, true, false, 0, w->shadow_paint.pict,
 	       w->shadow_paint.ptex, reg_paint, NULL);
 }
 
@@ -634,7 +729,7 @@
  */
 static bool xr_blur_dst(session_t *ps, xcb_render_picture_t tgt_buffer, int16_t x, int16_t y,
                         uint16_t wid, uint16_t hei, struct x_convolution_kernel **blur_kerns,
-                        int nkernels, const region_t *reg_clip) {
+                        int nkernels, const region_t *reg_clip, xcb_render_picture_t rounded) {
 	assert(blur_kerns);
 	assert(blur_kerns[0]);
 
@@ -679,7 +774,7 @@
 	}
 
 	if (src_pict != tgt_buffer)
-		xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_SRC, src_pict, XCB_NONE,
+		xcb_render_composite(ps->c, XCB_RENDER_PICT_OP_OVER, src_pict, rounded,
 		                     tgt_buffer, 0, 0, 0, 0, x, y, wid, hei);
 
 	free_picture(ps->c, &tmp_picture);
@@ -697,6 +792,8 @@
 	const int16_t y = w->g.y;
 	const auto wid = to_u16_checked(w->widthb);
 	const auto hei = to_u16_checked(w->heightb);
+    //TODO: This really needs refactoring into a function
+    const int cr = w && !win_is_fullscreen(ps, w) && !c2_match(ps, w, ps->o.rounded_corners_blacklist, NULL) ? w->corner_radius : 0;
 
 	double factor_center = 1.0;
 	// Adjust blur strength according to window opacity, to make it appear
@@ -728,21 +825,36 @@
 			                            &ps->blur_kerns_cache[i]);
 		}
 
+        xcb_render_picture_t td = XCB_NONE;
+        if (cr) {
+            uint32_t max_ntraps = to_u32_checked(cr);
+            xcb_render_trapezoid_t traps[4 * max_ntraps + 5];
+            uint32_t n = make_rounded_window_shape(traps, max_ntraps, cr, wid, hei);
+
+            td = x_create_picture_with_standard(ps->c, ps->root, wid, hei, XCB_PICT_STANDARD_ARGB_32, 0, 0);
+            xcb_render_color_t trans = {.red = 0, .blue = 0, .green = 0, .alpha = 0};
+            const xcb_rectangle_t rect = {.x = 0, .y = 0, .width = to_u16_checked(wid), .height = to_u16_checked(hei)};
+            xcb_render_fill_rectangles(ps->c, XCB_RENDER_PICT_OP_SRC, td, trans, 1, &rect);
+
+            xcb_render_trapezoids(ps->c, XCB_RENDER_PICT_OP_OVER, solid_picture(ps->c, ps->root, false, 1, 0, 0, 0), td, x_get_pictfmt_for_standard(ps->c, XCB_PICT_STANDARD_A_8), 0, 0, n, traps);
+        }
+
 		// Minimize the region we try to blur, if the window itself is not
 		// opaque, only the frame is.
-		region_t reg_blur = win_get_bounding_shape_global_by_val(w);
+		region_t reg_blur = win_get_bounding_shape_global_by_val(w, true);
 		if (w->mode == WMODE_FRAME_TRANS && !ps->o.force_win_blend) {
 			region_t reg_noframe;
 			pixman_region32_init(&reg_noframe);
-			win_get_region_noframe_local(w, &reg_noframe);
+			win_get_region_noframe_local(w, &reg_noframe, true);
 			pixman_region32_translate(&reg_noframe, w->g.x, w->g.y);
 			pixman_region32_subtract(&reg_blur, &reg_blur, &reg_noframe);
 			pixman_region32_fini(&reg_noframe);
 		}
+        
 		// Translate global coordinates to local ones
 		pixman_region32_translate(&reg_blur, -x, -y);
 		xr_blur_dst(ps, tgt_buffer, x, y, wid, hei, ps->blur_kerns_cache,
-		            ps->o.blur_kernel_count, &reg_blur);
+		            ps->o.blur_kernel_count, &reg_blur, td);
 		pixman_region32_clear(&reg_blur);
 	} break;
 #ifdef CONFIG_OPENGL
@@ -851,7 +963,8 @@
 	//
 	// Whether this is beneficial is to be determined XXX
 	for (auto w = t; w; w = w->prev_trans) {
-		region_t bshape = win_get_bounding_shape_global_by_val(w);
+		region_t bshape_no_corners = win_get_bounding_shape_global_by_val(w, false);
+        region_t bshape_corners = win_get_bounding_shape_global_by_val(w, true);
 		// Painting shadow
 		if (w->shadow) {
 			// Lazy shadow building
@@ -880,7 +993,7 @@
 			// saving GPU power and handling shaped windows (XXX
 			// unconfirmed)
 			if (!ps->o.wintype_option[w->window_type].full_shadow)
-				pixman_region32_subtract(&reg_tmp, &reg_tmp, &bshape);
+				pixman_region32_subtract(&reg_tmp, &reg_tmp, &bshape_no_corners);
 
 			if (ps->o.xinerama_shadow_crop && w->xinerama_scr >= 0 &&
 			    w->xinerama_scr < ps->xinerama_nscrs)
@@ -907,8 +1020,9 @@
 		// Remember, reg_ignore is the union of all windows above the current
 		// window.
 		pixman_region32_subtract(&reg_tmp, &region, w->reg_ignore);
-		pixman_region32_intersect(&reg_tmp, &reg_tmp, &bshape);
-		pixman_region32_fini(&bshape);
+		pixman_region32_intersect(&reg_tmp, &reg_tmp, &bshape_corners);
+		pixman_region32_fini(&bshape_corners);
+        pixman_region32_fini(&bshape_no_corners);
 
 		if (pixman_region32_not_empty(&reg_tmp)) {
 			set_tgt_clip(ps, &reg_tmp);
--- old/src/render.h
+++ new/src/render.h
@@ -25,8 +25,8 @@
 #endif
 } paint_t;
 
-void render(session_t *ps, int x, int y, int dx, int dy, int w, int h, double opacity,
-            bool argb, bool neg, xcb_render_picture_t pict, glx_texture_t *ptex,
+void render(session_t *ps, int x, int y, int dx, int dy, int w, int h, int fullw, int fullh, double opacity,
+            bool argb, bool neg, int cr, xcb_render_picture_t pict, glx_texture_t *ptex,
             const region_t *reg_paint, const glx_prog_main_t *pprogram);
 void paint_one(session_t *ps, struct managed_win *w, const region_t *reg_paint);
 
--- old/src/win.c
+++ new/src/win.c
@@ -58,6 +58,17 @@
 
 /// Generate a "return by value" function, from a function that returns the
 /// region via a region_t pointer argument.
+/// Function signature has to be (win *, region_t *, bool)
+#define gen_by_val_corners(fun)                                                                  \
+	region_t fun##_by_val(const struct managed_win *w, bool include_corners) {                             \
+		region_t ret;                                                            \
+		pixman_region32_init(&ret);                                              \
+		fun(w, &ret, include_corners);                                                            \
+		return ret;                                                              \
+	}
+
+/// Generate a "return by value" function, from a function that returns the
+/// region via a region_t pointer argument.
 /// Function signature has to be (win *, region_t *)
 #define gen_by_val(fun)                                                                  \
 	region_t fun##_by_val(const struct managed_win *w) {                             \
@@ -173,16 +184,18 @@
 /**
  * Get a rectangular region a window occupies, excluding shadow.
  */
-static void win_get_region_local(const struct managed_win *w, region_t *res) {
+static void win_get_region_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	assert(w->widthb >= 0 && w->heightb >= 0);
 	pixman_region32_fini(res);
 	pixman_region32_init_rect(res, 0, 0, (uint)w->widthb, (uint)w->heightb);
+
+    if(!include_corners) win_region_remove_corners(w, res);
 }
 
 /**
  * Get a rectangular region a window occupies, excluding frame and shadow.
  */
-void win_get_region_noframe_local(const struct managed_win *w, region_t *res) {
+void win_get_region_noframe_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	const margin_t extents = win_calc_frame_extents(w);
 
 	int x = extents.left;
@@ -193,10 +206,11 @@
 	pixman_region32_fini(res);
 	if (width > 0 && height > 0) {
 		pixman_region32_init_rect(res, x, y, (uint)width, (uint)height);
+		if(!include_corners) win_region_remove_corners(w, res);
 	}
 }
 
-void win_get_region_frame_local(const struct managed_win *w, region_t *res) {
+void win_get_region_frame_local(const struct managed_win *w, region_t *res, bool include_corners) {
 	const margin_t extents = win_calc_frame_extents(w);
 	auto outer_width = extents.left + extents.right + w->g.width;
 	auto outer_height = extents.top + extents.bottom + w->g.height;
@@ -219,10 +233,11 @@
 	region_t reg_win;
 	pixman_region32_init_rects(&reg_win, (rect_t[]){0, 0, outer_width, outer_height}, 1);
 	pixman_region32_intersect(res, &reg_win, res);
+    if(!include_corners) win_region_remove_corners(w, res);
 	pixman_region32_fini(&reg_win);
 }
 
-gen_by_val(win_get_region_frame_local);
+gen_by_val_corners(win_get_region_frame_local);
 
 /**
  * Add a window to damaged area.
@@ -1230,6 +1245,8 @@
 	    // Initialized during paint
 	    .paint = PAINT_INIT,
 	    .shadow_paint = PAINT_INIT,
+
+	    .corner_radius = 0,
 	};
 
 	assert(!w->destroyed);
@@ -1519,7 +1536,7 @@
 
 	pixman_region32_clear(&w->bounding_shape);
 	// Start with the window rectangular region
-	win_get_region_local(w, &w->bounding_shape);
+	win_get_region_local(w, &w->bounding_shape, true);
 
 	// Only request for a bounding region if the window is shaped
 	// (while loop is used to avoid goto, not an actual loop)
--- old/src/win.h
+++ new/src/win.h
@@ -202,6 +200,9 @@
 	/// Last window opacity value set by the rules.
 	double opacity_set;
 
+	/// Corner radius
+	int corner_radius;
+
 	// Fading-related members
 	/// Override value of window fade state. Set by D-Bus method calls.
 	switch_t fade_force;
@@ -357,12 +358,12 @@
  *
  * Return region in global coordinates.
  */
-void win_get_region_noframe_local(const struct managed_win *w, region_t *);
+void win_get_region_noframe_local(const struct managed_win *w, region_t *, bool include_corners);
 
 /// Get the region for the frame of the window
-void win_get_region_frame_local(const struct managed_win *w, region_t *res);
+void win_get_region_frame_local(const struct managed_win *w, region_t *res, bool include_corners);
 /// Get the region for the frame of the window, by value
-region_t win_get_region_frame_local_by_val(const struct managed_win *w);
+region_t win_get_region_frame_local_by_val(const struct managed_win *w, bool include_corners);
 /**
  * Retrieve frame extents from a window.
  */
@@ -438,10 +439,25 @@
 /// Free all resources in a struct win
 void free_win_res(session_t *ps, struct managed_win *w);
 
-static inline region_t win_get_bounding_shape_global_by_val(struct managed_win *w) {
+static inline void win_region_remove_corners(const struct managed_win *w, region_t *res) {
+    region_t corners;
+    pixman_region32_init_rects(
+        &corners,
+        (rect_t[]){
+            {.x1 = 0, .y1 = 0, .x2 = w->corner_radius, .y2 = w->corner_radius},
+            {.x1 = 0, .y1 = w->heightb-w->corner_radius, .x2 = w->corner_radius, .y2 = w->heightb},
+            {.x1 = w->widthb-w->corner_radius, .y1 = 0, .x2 = w->widthb, .y2 = w->corner_radius},
+            {.x1 = w->widthb-w->corner_radius, .y1 = w->heightb-w->corner_radius, .x2 = w->widthb, .y2 = w->heightb},
+        },
+        4);
+    pixman_region32_subtract(res, res, &corners);
+}
+
+static inline region_t win_get_bounding_shape_global_by_val(struct managed_win *w, bool include_corners) {
 	region_t ret;
 	pixman_region32_init(&ret);
 	pixman_region32_copy(&ret, &w->bounding_shape);
+    if(!include_corners) win_region_remove_corners(w, &ret);
 	pixman_region32_translate(&ret, w->g.x, w->g.y);
 	return ret;
 }
--- old/src/x.c
+++ new/src/x.c
@@ -167,6 +167,15 @@
 	return x_get_visual_for_pictfmt(g_pictfmts, pictfmt->id);
 }
 
+xcb_render_pictformat_t
+x_get_pictfmt_for_standard(xcb_connection_t *c, xcb_pict_standard_t std) {
+	x_get_server_pictfmts(c);
+
+	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, std);
+
+	return pictfmt->id;
+}
+
 int x_get_visual_depth(xcb_connection_t *c, xcb_visualid_t visual) {
 	auto setup = xcb_get_setup(c);
 	for (auto screen = xcb_setup_roots_iterator(setup); screen.rem;
@@ -229,6 +238,17 @@
 	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, standard);
 	assert(pictfmt);
 	return x_create_picture_with_pictfmt_and_pixmap(c, pictfmt, pixmap, valuemask, attr);
+}
+
+xcb_render_picture_t
+x_create_picture_with_standard(xcb_connection_t *c, xcb_drawable_t d, int w, int h,
+                               xcb_pict_standard_t standard, uint32_t valuemask,
+                               const xcb_render_create_picture_value_list_t *attr) {
+	x_get_server_pictfmts(c);
+
+	auto pictfmt = xcb_render_util_find_standard_format(g_pictfmts, standard);
+	assert(pictfmt);
+	return x_create_picture_with_pictfmt(c, d, w, h, pictfmt, valuemask, attr);
 }
 
 /**
--- old/src/x.h
+++ new/src/x.h
@@ -167,6 +167,12 @@
                                           const xcb_render_create_picture_value_list_t *attr)
     attr_nonnull(1);
 
+xcb_render_picture_t
+x_create_picture_with_standard(xcb_connection_t *c, xcb_drawable_t d, int w, int h,
+                               xcb_pict_standard_t standard, uint32_t valuemask,
+                               const xcb_render_create_picture_value_list_t *attr)
+    attr_nonnull(1);
+
 /**
  * Create an picture.
  */
@@ -249,6 +255,9 @@
 struct xvisual_info x_get_visual_info(xcb_connection_t *c, xcb_visualid_t visual);
 
 xcb_visualid_t x_get_visual_for_standard(xcb_connection_t *c, xcb_pict_standard_t std);
+
+xcb_render_pictformat_t
+x_get_pictfmt_for_standard(xcb_connection_t *c, xcb_pict_standard_t std);
 
 xcb_screen_t *x_screen_of_display(xcb_connection_t *c, int screen);
 
